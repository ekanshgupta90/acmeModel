import ROSFam.acme;
 
System Turtlebot : ROSFam = new ROSFam extended with {

    Component __amclnode : ROSNodeCompT = new ROSNodeCompT extended with {
        Port sport0 : TopicSubscribePortT = new TopicSubscribePortT extended with {

            Property topic : string = "/scan";

            Property msg_type : string = "sensor_msgs/LaserScan";
            rule attachedOnlyToReceiverRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, ReceiverRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToSubscriberRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, SubscriberRoleT);

        }
        Port sport1 : TopicSubscribePortT = new TopicSubscribePortT extended with {

            Property topic : string = "/initialpose";

            Property msg_type : string = "geometry_msgs/PoseWithCovarianceStamped";
            rule attachedOnlyToReceiverRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, ReceiverRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToSubscriberRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, SubscriberRoleT);

        }
        Port sport2 : TopicSubscribePortT = new TopicSubscribePortT extended with {

            Property topic : string = "/tf";

            Property msg_type : string = "tf2_msgs/TFMessage";
            rule attachedOnlyToReceiverRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, ReceiverRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToSubscriberRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, SubscriberRoleT);

        }
        Port sport3 : TopicSubscribePortT = new TopicSubscribePortT extended with {

            Property topic : string = "/tf_static";

            Property msg_type : string = "tf2_msgs/TFMessage";
            rule attachedOnlyToReceiverRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, ReceiverRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToSubscriberRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, SubscriberRoleT);

        }
        Port sport4 : TopicSubscribePortT = new TopicSubscribePortT extended with {

            Property topic : string = "/clock";

            Property msg_type : string = "rosgraph_msgs/Clock";
            rule attachedOnlyToReceiverRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, ReceiverRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToSubscriberRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, SubscriberRoleT);

        }
        Port pport0 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/particlecloud";

            Property msg_type : string = "geometry_msgs/PoseArray";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport1 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/tf";

            Property msg_type : string = "tf2_msgs/TFMessage";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport2 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/rosout";

            Property msg_type : string = "rosgraph_msgs/Log";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport3 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/amcl_pose";

            Property msg_type : string = "geometry_msgs/PoseWithCovarianceStamped";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport4 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/amcl/parameter_descriptions";

            Property msg_type : string = "dynamic_reconfigure/ConfigDescription";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport5 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/amcl/parameter_updates";

            Property msg_type : string = "dynamic_reconfigure/Config";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port serport0 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "roscpp/GetLoggers";

            Property args : string = "	";

            Property name : string = "get_loggers";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }
        Port serport1 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "roscpp/SetLoggerLevel";

            Property args : string = "logger	level	";

            Property name : string = "set_logger_level";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }
        Port serport2 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "dynamic_reconfigure/Reconfigure";

            Property args : string = "config	";

            Property name : string = "set_parameters";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }

        Property name : string = "/amcl";
        rule noServiceCallToSelf = invariant forall req :! ServiceClientPortT in self.PORTS | 
             ! exists resp :! ServiceProviderPortT in self.PORTS | 
                connected(req, resp);
        rule noActionCalLToSelf = invariant forall req :! ActionClientPortT in self.PORTS | 
             ! exists resp :! ActionServerPortT in self.PORTS | 
                connected(req, resp);

    }
    Component __handler_9956_1476197144897node : ROSNodeCompT = new ROSNodeCompT extended with {
        Port sport0 : TopicSubscribePortT = new TopicSubscribePortT extended with {

            Property topic : string = "/clock";

            Property msg_type : string = "rosgraph_msgs/Clock";
            rule attachedOnlyToReceiverRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, ReceiverRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToSubscriberRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, SubscriberRoleT);

        }
        Port pport0 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/rosout";

            Property msg_type : string = "rosgraph_msgs/Log";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port serport0 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "roscpp/SetLoggerLevel";

            Property args : string = "logger	level	";

            Property name : string = "set_logger_level";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }
        Port serport1 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "roscpp/GetLoggers";

            Property args : string = "	";

            Property name : string = "get_loggers";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }

        Property name : string = "/handler_9956_1476197144897";
        rule noServiceCallToSelf = invariant forall req :! ServiceClientPortT in self.PORTS | 
             ! exists resp :! ServiceProviderPortT in self.PORTS | 
                connected(req, resp);
        rule noActionCalLToSelf = invariant forall req :! ActionClientPortT in self.PORTS | 
             ! exists resp :! ActionServerPortT in self.PORTS | 
                connected(req, resp);

    }
    Component __robot_state_publishernode : ROSNodeCompT = new ROSNodeCompT extended with {
        Port sport0 : TopicSubscribePortT = new TopicSubscribePortT extended with {

            Property topic : string = "/joint_states";

            Property msg_type : string = "sensor_msgs/JointState";
            rule attachedOnlyToReceiverRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, ReceiverRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToSubscriberRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, SubscriberRoleT);

        }
        Port sport1 : TopicSubscribePortT = new TopicSubscribePortT extended with {

            Property topic : string = "/clock";

            Property msg_type : string = "rosgraph_msgs/Clock";
            rule attachedOnlyToReceiverRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, ReceiverRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToSubscriberRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, SubscriberRoleT);

        }
        Port pport0 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/tf";

            Property msg_type : string = "tf2_msgs/TFMessage";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport1 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/tf_static";

            Property msg_type : string = "tf2_msgs/TFMessage";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport2 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/rosout";

            Property msg_type : string = "rosgraph_msgs/Log";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port serport0 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "roscpp/GetLoggers";

            Property args : string = "	";

            Property name : string = "get_loggers";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }
        Port serport1 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "roscpp/SetLoggerLevel";

            Property args : string = "logger	level	";

            Property name : string = "set_logger_level";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }

        Property name : string = "/robot_state_publisher";
        rule noServiceCallToSelf = invariant forall req :! ServiceClientPortT in self.PORTS | 
             ! exists resp :! ServiceProviderPortT in self.PORTS | 
                connected(req, resp);
        rule noActionCalLToSelf = invariant forall req :! ActionClientPortT in self.PORTS | 
             ! exists resp :! ActionServerPortT in self.PORTS | 
                connected(req, resp);

    }
    Component __rosoutnode : ROSNodeCompT = new ROSNodeCompT extended with {
        Port sport0 : TopicSubscribePortT = new TopicSubscribePortT extended with {

            Property topic : string = "/rosout";

            Property msg_type : string = "rosgraph_msgs/Log";
            rule attachedOnlyToReceiverRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, ReceiverRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToSubscriberRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, SubscriberRoleT);

        }
        Port sport1 : TopicSubscribePortT = new TopicSubscribePortT extended with {

            Property topic : string = "/clock";

            Property msg_type : string = "rosgraph_msgs/Clock";
            rule attachedOnlyToReceiverRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, ReceiverRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToSubscriberRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, SubscriberRoleT);

        }
        Port pport0 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/rosout_agg";

            Property msg_type : string = "rosgraph_msgs/Log";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port serport0 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "roscpp/GetLoggers";

            Property args : string = "	";

            Property name : string = "get_loggers";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }
        Port serport1 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "roscpp/SetLoggerLevel";

            Property args : string = "logger	level	";

            Property name : string = "set_logger_level";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }

        Property name : string = "/rosout";
        rule noServiceCallToSelf = invariant forall req :! ServiceClientPortT in self.PORTS | 
             ! exists resp :! ServiceProviderPortT in self.PORTS | 
                connected(req, resp);
        rule noActionCalLToSelf = invariant forall req :! ActionClientPortT in self.PORTS | 
             ! exists resp :! ActionServerPortT in self.PORTS | 
                connected(req, resp);

    }
    Component __rviznode : ROSNodeCompT = new ROSNodeCompT extended with {
        Port sport0 : TopicSubscribePortT = new TopicSubscribePortT extended with {

            Property topic : string = "/scan";

            Property msg_type : string = "sensor_msgs/LaserScan";
            rule attachedOnlyToReceiverRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, ReceiverRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToSubscriberRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, SubscriberRoleT);

        }
        Port sport1 : TopicSubscribePortT = new TopicSubscribePortT extended with {

            Property topic : string = "/move_base/NavfnROS/plan";

            Property msg_type : string = "nav_msgs/Path";
            rule attachedOnlyToReceiverRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, ReceiverRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToSubscriberRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, SubscriberRoleT);

        }
        Port sport2 : TopicSubscribePortT = new TopicSubscribePortT extended with {

            Property topic : string = "/move_base/local_costmap/costmap";

            Property msg_type : string = "nav_msgs/OccupancyGrid";
            rule attachedOnlyToReceiverRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, ReceiverRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToSubscriberRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, SubscriberRoleT);

        }
        Port sport3 : TopicSubscribePortT = new TopicSubscribePortT extended with {

            Property topic : string = "/particlecloud";

            Property msg_type : string = "geometry_msgs/PoseArray";
            rule attachedOnlyToReceiverRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, ReceiverRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToSubscriberRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, SubscriberRoleT);

        }
        Port sport4 : TopicSubscribePortT = new TopicSubscribePortT extended with {

            Property topic : string = "/move_base/DWAPlannerROS/global_plan";

            Property msg_type : string = "nav_msgs/Path";
            rule attachedOnlyToReceiverRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, ReceiverRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToSubscriberRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, SubscriberRoleT);

        }
        Port sport5 : TopicSubscribePortT = new TopicSubscribePortT extended with {

            Property topic : string = "/move_base/DWAPlannerROS/cost_cloud";

            Property msg_type : string = "sensor_msgs/PointCloud2";
            rule attachedOnlyToReceiverRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, ReceiverRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToSubscriberRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, SubscriberRoleT);

        }
        Port sport6 : TopicSubscribePortT = new TopicSubscribePortT extended with {

            Property topic : string = "/move_base/global_costmap/costmap_updates";

            Property msg_type : string = "map_msgs/OccupancyGridUpdate";
            rule attachedOnlyToReceiverRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, ReceiverRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToSubscriberRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, SubscriberRoleT);

        }
        Port sport7 : TopicSubscribePortT = new TopicSubscribePortT extended with {

            Property topic : string = "/tf";

            Property msg_type : string = "tf2_msgs/TFMessage";
            rule attachedOnlyToReceiverRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, ReceiverRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToSubscriberRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, SubscriberRoleT);

        }
        Port sport8 : TopicSubscribePortT = new TopicSubscribePortT extended with {

            Property topic : string = "/move_base/DWAPlannerROS/trajectory_cloud";

            Property msg_type : string = "sensor_msgs/PointCloud2";
            rule attachedOnlyToReceiverRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, ReceiverRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToSubscriberRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, SubscriberRoleT);

        }
        Port sport9 : TopicSubscribePortT = new TopicSubscribePortT extended with {

            Property topic : string = "/move_base/local_costmap/costmap_updates";

            Property msg_type : string = "map_msgs/OccupancyGridUpdate";
            rule attachedOnlyToReceiverRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, ReceiverRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToSubscriberRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, SubscriberRoleT);

        }
        Port sport10 : TopicSubscribePortT = new TopicSubscribePortT extended with {

            Property topic : string = "/tf_static";

            Property msg_type : string = "tf2_msgs/TFMessage";
            rule attachedOnlyToReceiverRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, ReceiverRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToSubscriberRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, SubscriberRoleT);

        }
        Port sport11 : TopicSubscribePortT = new TopicSubscribePortT extended with {

            Property topic : string = "/move_base/global_costmap/costmap";

            Property msg_type : string = "nav_msgs/OccupancyGrid";
            rule attachedOnlyToReceiverRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, ReceiverRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToSubscriberRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, SubscriberRoleT);

        }
        Port sport12 : TopicSubscribePortT = new TopicSubscribePortT extended with {

            Property topic : string = "/mobile_base/sensors/bumper_pointcloud";

            Property msg_type : string = "sensor_msgs/PointCloud2";
            rule attachedOnlyToReceiverRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, ReceiverRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToSubscriberRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, SubscriberRoleT);

        }
        Port sport13 : TopicSubscribePortT = new TopicSubscribePortT extended with {

            Property topic : string = "/clock";

            Property msg_type : string = "rosgraph_msgs/Clock";
            rule attachedOnlyToReceiverRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, ReceiverRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToSubscriberRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, SubscriberRoleT);

        }
        Port sport14 : TopicSubscribePortT = new TopicSubscribePortT extended with {

            Property topic : string = "/map";

            Property msg_type : string = "nav_msgs/OccupancyGrid";
            rule attachedOnlyToReceiverRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, ReceiverRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToSubscriberRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, SubscriberRoleT);

        }
        Port sport15 : TopicSubscribePortT = new TopicSubscribePortT extended with {

            Property topic : string = "/move_base/DWAPlannerROS/local_plan";

            Property msg_type : string = "nav_msgs/Path";
            rule attachedOnlyToReceiverRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, ReceiverRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToSubscriberRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, SubscriberRoleT);

        }
        Port pport0 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/clicked_point";

            Property msg_type : string = "geometry_msgs/PointStamped";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport1 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/initialpose";

            Property msg_type : string = "geometry_msgs/PoseWithCovarianceStamped";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport2 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/rosout";

            Property msg_type : string = "rosgraph_msgs/Log";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport3 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/move_base_simple/goal";

            Property msg_type : string = "geometry_msgs/PoseStamped";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port serport0 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "roscpp/SetLoggerLevel";

            Property args : string = "logger	level	";

            Property name : string = "set_logger_level";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }
        Port serport1 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "std_srvs/Empty";

            Property args : string = "	";

            Property name : string = "reload_shaders";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }
        Port serport2 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "roscpp/GetLoggers";

            Property args : string = "	";

            Property name : string = "get_loggers";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }

        Property name : string = "/rviz";
        rule noServiceCallToSelf = invariant forall req :! ServiceClientPortT in self.PORTS | 
             ! exists resp :! ServiceProviderPortT in self.PORTS | 
                connected(req, resp);
        rule noActionCalLToSelf = invariant forall req :! ActionClientPortT in self.PORTS | 
             ! exists resp :! ActionServerPortT in self.PORTS | 
                connected(req, resp);

    }
    Component __map_servernode : ROSNodeCompT = new ROSNodeCompT extended with {
        Port sport0 : TopicSubscribePortT = new TopicSubscribePortT extended with {

            Property topic : string = "/clock";

            Property msg_type : string = "rosgraph_msgs/Clock";
            rule attachedOnlyToReceiverRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, ReceiverRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToSubscriberRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, SubscriberRoleT);

        }
        Port pport0 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/map_metadata";

            Property msg_type : string = "nav_msgs/MapMetaData";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport1 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/rosout";

            Property msg_type : string = "rosgraph_msgs/Log";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport2 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/map";

            Property msg_type : string = "nav_msgs/OccupancyGrid";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port serport0 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "roscpp/SetLoggerLevel";

            Property args : string = "logger	level	";

            Property name : string = "set_logger_level";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }
        Port serport1 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "roscpp/GetLoggers";

            Property args : string = "	";

            Property name : string = "get_loggers";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }

        Property name : string = "/map_server";
        rule noServiceCallToSelf = invariant forall req :! ServiceClientPortT in self.PORTS | 
             ! exists resp :! ServiceProviderPortT in self.PORTS | 
                connected(req, resp);
        rule noActionCalLToSelf = invariant forall req :! ActionClientPortT in self.PORTS | 
             ! exists resp :! ActionServerPortT in self.PORTS | 
                connected(req, resp);

    }
    Component __euler_orientationnode : ROSNodeCompT = new ROSNodeCompT extended with {
        Port sport0 : TopicSubscribePortT = new TopicSubscribePortT extended with {

            Property topic : string = "/odom";

            Property msg_type : string = "nav_msgs/Odometry";
            rule attachedOnlyToReceiverRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, ReceiverRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToSubscriberRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, SubscriberRoleT);

        }
        Port sport1 : TopicSubscribePortT = new TopicSubscribePortT extended with {

            Property topic : string = "/clock";

            Property msg_type : string = "rosgraph_msgs/Clock";
            rule attachedOnlyToReceiverRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, ReceiverRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToSubscriberRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, SubscriberRoleT);

        }
        Port pport0 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/euler_orientation";

            Property msg_type : string = "messages/euler";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport1 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/rosout";

            Property msg_type : string = "rosgraph_msgs/Log";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port serport0 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "roscpp/GetLoggers";

            Property args : string = "	";

            Property name : string = "get_loggers";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }
        Port serport1 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "roscpp/SetLoggerLevel";

            Property args : string = "logger	level	";

            Property name : string = "set_logger_level";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }

        Property name : string = "/euler_orientation";
        rule noServiceCallToSelf = invariant forall req :! ServiceClientPortT in self.PORTS | 
             ! exists resp :! ServiceProviderPortT in self.PORTS | 
                connected(req, resp);
        rule noActionCalLToSelf = invariant forall req :! ActionClientPortT in self.PORTS | 
             ! exists resp :! ActionServerPortT in self.PORTS | 
                connected(req, resp);

    }
    Component __move_basenode : ROSNodeCompT = new ROSNodeCompT extended with {
        Port sport0 : TopicSubscribePortT = new TopicSubscribePortT extended with {

            Property topic : string = "/move_base/local_costmap/footprint";

            Property msg_type : string = "geometry_msgs/PolygonStamped";
            rule attachedOnlyToReceiverRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, ReceiverRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToSubscriberRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, SubscriberRoleT);

        }
        Port sport1 : TopicSubscribePortT = new TopicSubscribePortT extended with {

            Property topic : string = "/scan";

            Property msg_type : string = "sensor_msgs/LaserScan";
            rule attachedOnlyToReceiverRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, ReceiverRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToSubscriberRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, SubscriberRoleT);

        }
        Port sport2 : TopicSubscribePortT = new TopicSubscribePortT extended with {

            Property topic : string = "/move_base/global_costmap/footprint";

            Property msg_type : string = "geometry_msgs/PolygonStamped";
            rule attachedOnlyToReceiverRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, ReceiverRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToSubscriberRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, SubscriberRoleT);

        }
        Port sport3 : TopicSubscribePortT = new TopicSubscribePortT extended with {

            Property topic : string = "/move_base/goal";

            Property msg_type : string = "move_base_msgs/MoveBaseActionGoal";
            rule attachedOnlyToReceiverRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, ReceiverRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToSubscriberRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, SubscriberRoleT);

        }
        Port sport4 : TopicSubscribePortT = new TopicSubscribePortT extended with {

            Property topic : string = "/tf";

            Property msg_type : string = "tf2_msgs/TFMessage";
            rule attachedOnlyToReceiverRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, ReceiverRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToSubscriberRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, SubscriberRoleT);

        }
        Port sport5 : TopicSubscribePortT = new TopicSubscribePortT extended with {

            Property topic : string = "/tf_static";

            Property msg_type : string = "tf2_msgs/TFMessage";
            rule attachedOnlyToReceiverRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, ReceiverRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToSubscriberRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, SubscriberRoleT);

        }
        Port sport6 : TopicSubscribePortT = new TopicSubscribePortT extended with {

            Property topic : string = "/move_base/cancel";

            Property msg_type : string = "actionlib_msgs/GoalID";
            rule attachedOnlyToReceiverRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, ReceiverRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToSubscriberRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, SubscriberRoleT);

        }
        Port sport7 : TopicSubscribePortT = new TopicSubscribePortT extended with {

            Property topic : string = "/odom";

            Property msg_type : string = "nav_msgs/Odometry";
            rule attachedOnlyToReceiverRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, ReceiverRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToSubscriberRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, SubscriberRoleT);

        }
        Port sport8 : TopicSubscribePortT = new TopicSubscribePortT extended with {

            Property topic : string = "/move_base_simple/goal";

            Property msg_type : string = "geometry_msgs/PoseStamped";
            rule attachedOnlyToReceiverRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, ReceiverRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToSubscriberRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, SubscriberRoleT);

        }
        Port sport9 : TopicSubscribePortT = new TopicSubscribePortT extended with {

            Property topic : string = "/mobile_base/sensors/bumper_pointcloud";

            Property msg_type : string = "sensor_msgs/PointCloud2";
            rule attachedOnlyToReceiverRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, ReceiverRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToSubscriberRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, SubscriberRoleT);

        }
        Port sport10 : TopicSubscribePortT = new TopicSubscribePortT extended with {

            Property topic : string = "/clock";

            Property msg_type : string = "rosgraph_msgs/Clock";
            rule attachedOnlyToReceiverRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, ReceiverRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToSubscriberRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, SubscriberRoleT);

        }
        Port sport11 : TopicSubscribePortT = new TopicSubscribePortT extended with {

            Property topic : string = "/map";

            Property msg_type : string = "nav_msgs/OccupancyGrid";
            rule attachedOnlyToReceiverRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, ReceiverRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToSubscriberRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, SubscriberRoleT);

        }
        Port pport0 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/move_base/local_costmap/footprint";

            Property msg_type : string = "geometry_msgs/PolygonStamped";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport1 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/move_base/feedback";

            Property msg_type : string = "move_base_msgs/MoveBaseActionFeedback";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport2 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/move_base/NavfnROS/plan";

            Property msg_type : string = "nav_msgs/Path";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport3 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/move_base/global_costmap/footprint";

            Property msg_type : string = "geometry_msgs/PolygonStamped";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport4 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/move_base/local_costmap/obstacle_layer/parameter_updates";

            Property msg_type : string = "dynamic_reconfigure/Config";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport5 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/move_base/global_costmap/obstacle_layer/parameter_descriptions";

            Property msg_type : string = "dynamic_reconfigure/ConfigDescription";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport6 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/move_base/global_costmap/inflation_layer/parameter_descriptions";

            Property msg_type : string = "dynamic_reconfigure/ConfigDescription";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport7 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/move_base/current_goal";

            Property msg_type : string = "geometry_msgs/PoseStamped";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport8 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/move_base/local_costmap/costmap";

            Property msg_type : string = "nav_msgs/OccupancyGrid";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport9 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/navigation_velocity_smoother/raw_cmd_vel";

            Property msg_type : string = "geometry_msgs/Twist";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport10 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/move_base/local_costmap/inflation_layer/parameter_updates";

            Property msg_type : string = "dynamic_reconfigure/Config";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport11 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/move_base/parameter_updates";

            Property msg_type : string = "dynamic_reconfigure/Config";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport12 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/move_base/DWAPlannerROS/global_plan";

            Property msg_type : string = "nav_msgs/Path";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport13 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/move_base/global_costmap/obstacle_layer/clearing_endpoints";

            Property msg_type : string = "sensor_msgs/PointCloud";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport14 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/move_base/DWAPlannerROS/cost_cloud";

            Property msg_type : string = "sensor_msgs/PointCloud2";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport15 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/move_base/local_costmap/parameter_updates";

            Property msg_type : string = "dynamic_reconfigure/Config";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport16 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/move_base/goal";

            Property msg_type : string = "move_base_msgs/MoveBaseActionGoal";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport17 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/move_base/global_costmap/obstacle_layer/parameter_updates";

            Property msg_type : string = "dynamic_reconfigure/Config";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport18 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/move_base/global_costmap/costmap_updates";

            Property msg_type : string = "map_msgs/OccupancyGridUpdate";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport19 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/move_base/local_costmap/inflation_layer/parameter_descriptions";

            Property msg_type : string = "dynamic_reconfigure/ConfigDescription";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport20 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/move_base/DWAPlannerROS/trajectory_cloud";

            Property msg_type : string = "sensor_msgs/PointCloud2";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport21 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/move_base/global_costmap/static_layer/parameter_updates";

            Property msg_type : string = "dynamic_reconfigure/Config";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport22 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/move_base/status";

            Property msg_type : string = "actionlib_msgs/GoalStatusArray";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport23 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/move_base/local_costmap/costmap_updates";

            Property msg_type : string = "map_msgs/OccupancyGridUpdate";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport24 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/move_base/local_costmap/parameter_descriptions";

            Property msg_type : string = "dynamic_reconfigure/ConfigDescription";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport25 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/move_base/global_costmap/inflation_layer/parameter_updates";

            Property msg_type : string = "dynamic_reconfigure/Config";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport26 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/move_base/DWAPlannerROS/parameter_descriptions";

            Property msg_type : string = "dynamic_reconfigure/ConfigDescription";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport27 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/rosout";

            Property msg_type : string = "rosgraph_msgs/Log";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport28 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/move_base/local_costmap/obstacle_layer/clearing_endpoints";

            Property msg_type : string = "sensor_msgs/PointCloud";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport29 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/move_base/global_costmap/costmap";

            Property msg_type : string = "nav_msgs/OccupancyGrid";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport30 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/move_base/DWAPlannerROS/parameter_updates";

            Property msg_type : string = "dynamic_reconfigure/Config";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport31 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/move_base/parameter_descriptions";

            Property msg_type : string = "dynamic_reconfigure/ConfigDescription";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport32 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/move_base/global_costmap/parameter_updates";

            Property msg_type : string = "dynamic_reconfigure/Config";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport33 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/move_base/global_costmap/static_layer/parameter_descriptions";

            Property msg_type : string = "dynamic_reconfigure/ConfigDescription";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport34 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/move_base/local_costmap/obstacle_layer/parameter_descriptions";

            Property msg_type : string = "dynamic_reconfigure/ConfigDescription";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport35 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/move_base/global_costmap/parameter_descriptions";

            Property msg_type : string = "dynamic_reconfigure/ConfigDescription";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport36 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/move_base/result";

            Property msg_type : string = "move_base_msgs/MoveBaseActionResult";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport37 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/move_base/DWAPlannerROS/local_plan";

            Property msg_type : string = "nav_msgs/Path";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port serport0 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "dynamic_reconfigure/Reconfigure";

            Property args : string = "config	";

            Property name : string = "DWAPlannerROS";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }
        Port serport1 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "std_srvs/Empty";

            Property args : string = "	";

            Property name : string = "clear_costmaps";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }
        Port serport2 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "nav_msgs/GetPlan";

            Property args : string = "start	goal	tolerance	";

            Property name : string = "NavfnROS";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }
        Port serport3 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "dynamic_reconfigure/Reconfigure";

            Property args : string = "config	";

            Property name : string = "global_costmap";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }
        Port serport4 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "dynamic_reconfigure/Reconfigure";

            Property args : string = "config	";

            Property name : string = "global_costmap";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }
        Port serport5 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "roscpp/SetLoggerLevel";

            Property args : string = "logger	level	";

            Property name : string = "set_logger_level";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }
        Port serport6 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "roscpp/GetLoggers";

            Property args : string = "	";

            Property name : string = "get_loggers";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }
        Port serport7 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "dynamic_reconfigure/Reconfigure";

            Property args : string = "config	";

            Property name : string = "local_costmap";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }
        Port serport8 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "dynamic_reconfigure/Reconfigure";

            Property args : string = "config	";

            Property name : string = "local_costmap";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }
        Port serport9 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "dynamic_reconfigure/Reconfigure";

            Property args : string = "config	";

            Property name : string = "local_costmap";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }
        Port serport10 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "dynamic_reconfigure/Reconfigure";

            Property args : string = "config	";

            Property name : string = "global_costmap";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }
        Port serport11 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "dynamic_reconfigure/Reconfigure";

            Property args : string = "config	";

            Property name : string = "global_costmap";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }
        Port serport12 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "dynamic_reconfigure/Reconfigure";

            Property args : string = "config	";

            Property name : string = "set_parameters";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }
        Port serport13 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "nav_msgs/GetPlan";

            Property args : string = "start	goal	tolerance	";

            Property name : string = "make_plan";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }

        Property name : string = "/move_base";
        rule noServiceCallToSelf = invariant forall req :! ServiceClientPortT in self.PORTS | 
             ! exists resp :! ServiceProviderPortT in self.PORTS | 
                connected(req, resp);
        rule noActionCalLToSelf = invariant forall req :! ActionClientPortT in self.PORTS | 
             ! exists resp :! ActionServerPortT in self.PORTS | 
                connected(req, resp);

    }
    Component __ig_action_servernode : ROSNodeCompT = new ROSNodeCompT extended with {
        Port sport0 : TopicSubscribePortT = new TopicSubscribePortT extended with {

            Property topic : string = "/move_base/feedback";

            Property msg_type : string = "move_base_msgs/MoveBaseActionFeedback";
            rule attachedOnlyToReceiverRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, ReceiverRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToSubscriberRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, SubscriberRoleT);

        }
        Port sport1 : TopicSubscribePortT = new TopicSubscribePortT extended with {

            Property topic : string = "/euler_orientation";

            Property msg_type : string = "messages/euler";
            rule attachedOnlyToReceiverRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, ReceiverRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToSubscriberRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, SubscriberRoleT);

        }
        Port sport2 : TopicSubscribePortT = new TopicSubscribePortT extended with {

            Property topic : string = "/ig_action_server/goal";

            Property msg_type : string = "ig_action_msgs/InstructionGraphActionGoal";
            rule attachedOnlyToReceiverRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, ReceiverRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToSubscriberRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, SubscriberRoleT);

        }
        Port sport3 : TopicSubscribePortT = new TopicSubscribePortT extended with {

            Property topic : string = "/move_base/status";

            Property msg_type : string = "actionlib_msgs/GoalStatusArray";
            rule attachedOnlyToReceiverRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, ReceiverRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToSubscriberRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, SubscriberRoleT);

        }
        Port sport4 : TopicSubscribePortT = new TopicSubscribePortT extended with {

            Property topic : string = "/clock";

            Property msg_type : string = "rosgraph_msgs/Clock";
            rule attachedOnlyToReceiverRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, ReceiverRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToSubscriberRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, SubscriberRoleT);

        }
        Port sport5 : TopicSubscribePortT = new TopicSubscribePortT extended with {

            Property topic : string = "/ig_action_server/cancel";

            Property msg_type : string = "actionlib_msgs/GoalID";
            rule attachedOnlyToReceiverRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, ReceiverRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToSubscriberRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, SubscriberRoleT);

        }
        Port sport6 : TopicSubscribePortT = new TopicSubscribePortT extended with {

            Property topic : string = "/move_base/result";

            Property msg_type : string = "move_base_msgs/MoveBaseActionResult";
            rule attachedOnlyToReceiverRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, ReceiverRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToSubscriberRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, SubscriberRoleT);

        }
        Port pport0 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/ig_action_server/feedback";

            Property msg_type : string = "ig_action_msgs/InstructionGraphActionFeedback";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport1 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/ig_action_server/status";

            Property msg_type : string = "actionlib_msgs/GoalStatusArray";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport2 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/ig_action_server/result";

            Property msg_type : string = "ig_action_msgs/InstructionGraphActionResult";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport3 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/move_base/goal";

            Property msg_type : string = "move_base_msgs/MoveBaseActionGoal";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport4 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/cmd_vel_mux/input/navi";

            Property msg_type : string = "geometry_msgs/Twist";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport5 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/rosout";

            Property msg_type : string = "rosgraph_msgs/Log";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport6 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/move_base/cancel";

            Property msg_type : string = "actionlib_msgs/GoalID";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport7 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/instructiongraphs_goal";

            Property msg_type : string = "std_msgs/String";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport8 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/instructiongraphs_status";

            Property msg_type : string = "std_msgs/String";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port serport0 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "roscpp/SetLoggerLevel";

            Property args : string = "logger	level	";

            Property name : string = "set_logger_level";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }
        Port serport1 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "roscpp/GetLoggers";

            Property args : string = "	";

            Property name : string = "get_loggers";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }

        Property name : string = "/ig_action_server";
        rule noServiceCallToSelf = invariant forall req :! ServiceClientPortT in self.PORTS | 
             ! exists resp :! ServiceProviderPortT in self.PORTS | 
                connected(req, resp);
        rule noActionCalLToSelf = invariant forall req :! ActionClientPortT in self.PORTS | 
             ! exists resp :! ActionServerPortT in self.PORTS | 
                connected(req, resp);

    }
    Component __ig_action_clientnode : ROSNodeCompT = new ROSNodeCompT extended with {
        Port sport0 : TopicSubscribePortT = new TopicSubscribePortT extended with {

            Property topic : string = "/ig_action_server/feedback";

            Property msg_type : string = "ig_action_msgs/InstructionGraphActionFeedback";
            rule attachedOnlyToReceiverRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, ReceiverRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToSubscriberRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, SubscriberRoleT);

        }
        Port sport1 : TopicSubscribePortT = new TopicSubscribePortT extended with {

            Property topic : string = "/ig_action_server/status";

            Property msg_type : string = "actionlib_msgs/GoalStatusArray";
            rule attachedOnlyToReceiverRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, ReceiverRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToSubscriberRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, SubscriberRoleT);

        }
        Port sport2 : TopicSubscribePortT = new TopicSubscribePortT extended with {

            Property topic : string = "/ig_action_server/result";

            Property msg_type : string = "ig_action_msgs/InstructionGraphActionResult";
            rule attachedOnlyToReceiverRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, ReceiverRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToSubscriberRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, SubscriberRoleT);

        }
        Port sport3 : TopicSubscribePortT = new TopicSubscribePortT extended with {

            Property topic : string = "/clock";

            Property msg_type : string = "rosgraph_msgs/Clock";
            rule attachedOnlyToReceiverRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, ReceiverRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToSubscriberRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, SubscriberRoleT);

        }
        Port pport0 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/ig_action_server/goal";

            Property msg_type : string = "ig_action_msgs/InstructionGraphActionGoal";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport1 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/rosout";

            Property msg_type : string = "rosgraph_msgs/Log";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport2 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/ig_action_server/cancel";

            Property msg_type : string = "actionlib_msgs/GoalID";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port serport0 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "roscpp/GetLoggers";

            Property args : string = "	";

            Property name : string = "get_loggers";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }
        Port serport1 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "roscpp/SetLoggerLevel";

            Property args : string = "logger	level	";

            Property name : string = "set_logger_level";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }

        Property name : string = "/ig_action_client";
        rule noServiceCallToSelf = invariant forall req :! ServiceClientPortT in self.PORTS | 
             ! exists resp :! ServiceProviderPortT in self.PORTS | 
                connected(req, resp);
        rule noActionCalLToSelf = invariant forall req :! ActionClientPortT in self.PORTS | 
             ! exists resp :! ActionServerPortT in self.PORTS | 
                connected(req, resp);

    }
    Component __gazebonode : ROSNodeCompT = new ROSNodeCompT extended with {
        Port sport0 : TopicSubscribePortT = new TopicSubscribePortT extended with {

            Property topic : string = "/mobile_base/commands/velocity";

            Property msg_type : string = "geometry_msgs/Twist";
            rule attachedOnlyToReceiverRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, ReceiverRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToSubscriberRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, SubscriberRoleT);

        }
        Port sport1 : TopicSubscribePortT = new TopicSubscribePortT extended with {

            Property topic : string = "/clock";

            Property msg_type : string = "rosgraph_msgs/Clock";
            rule attachedOnlyToReceiverRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, ReceiverRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToSubscriberRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, SubscriberRoleT);

        }
        Port pport0 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/camera/rgb/image_raw/theora/parameter_descriptions";

            Property msg_type : string = "dynamic_reconfigure/ConfigDescription";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport1 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/camera/rgb/camera_info";

            Property msg_type : string = "sensor_msgs/CameraInfo";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport2 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/camera/parameter_descriptions";

            Property msg_type : string = "dynamic_reconfigure/ConfigDescription";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport3 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/camera/rgb/image_raw/compressed/parameter_descriptions";

            Property msg_type : string = "dynamic_reconfigure/ConfigDescription";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport4 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/camera/rgb/image_raw/compressedDepth";

            Property msg_type : string = "sensor_msgs/CompressedImage";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport5 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/camera/rgb/image_raw/compressedDepth/parameter_descriptions";

            Property msg_type : string = "dynamic_reconfigure/ConfigDescription";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport6 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/gazebo/model_states";

            Property msg_type : string = "gazebo_msgs/ModelStates";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport7 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/camera/depth/points";

            Property msg_type : string = "sensor_msgs/PointCloud2";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport8 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/camera/rgb/image_raw/compressedDepth/parameter_updates";

            Property msg_type : string = "dynamic_reconfigure/Config";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport9 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/gazebo/parameter_descriptions";

            Property msg_type : string = "dynamic_reconfigure/ConfigDescription";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport10 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/mobile_base/events/bumper";

            Property msg_type : string = "kobuki_msgs/BumperEvent";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport11 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/mobile_base/sensors/imu_data";

            Property msg_type : string = "sensor_msgs/Imu";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport12 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/camera/rgb/image_raw";

            Property msg_type : string = "sensor_msgs/Image";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport13 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/tf";

            Property msg_type : string = "tf2_msgs/TFMessage";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport14 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/camera/rgb/image_raw/compressed";

            Property msg_type : string = "sensor_msgs/CompressedImage";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport15 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/camera/rgb/image_raw/compressed/parameter_updates";

            Property msg_type : string = "dynamic_reconfigure/Config";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport16 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/camera/parameter_updates";

            Property msg_type : string = "dynamic_reconfigure/Config";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport17 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/joint_states";

            Property msg_type : string = "sensor_msgs/JointState";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport18 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/rosout";

            Property msg_type : string = "rosgraph_msgs/Log";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport19 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/camera/depth/image_raw";

            Property msg_type : string = "sensor_msgs/Image";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport20 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/mobile_base/events/cliff";

            Property msg_type : string = "kobuki_msgs/CliffEvent";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport21 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/camera/rgb/image_raw/theora";

            Property msg_type : string = "theora_image_transport/Packet";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport22 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/camera/rgb/image_raw/theora/parameter_updates";

            Property msg_type : string = "dynamic_reconfigure/Config";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport23 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/gazebo/parameter_updates";

            Property msg_type : string = "dynamic_reconfigure/Config";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport24 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/odom";

            Property msg_type : string = "nav_msgs/Odometry";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport25 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/camera/depth/camera_info";

            Property msg_type : string = "sensor_msgs/CameraInfo";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport26 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/clock";

            Property msg_type : string = "rosgraph_msgs/Clock";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port pport27 : TopicAdvertisePortT = new TopicAdvertisePortT extended with {

            Property topic : string = "/gazebo/link_states";

            Property msg_type : string = "gazebo_msgs/LinkStates";
            rule attachedOnlyToAnnouncerRoleT = invariant forall a in self.ATTACHEDROLES | 
                declaresType(a, AnnouncerRoleT);
            rule exactly1Attachment = heuristic size(self.ATTACHEDROLES) == 1;
            rule attachedToPublisherRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, PublisherRoleT);

        }
        Port serport0 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "gazebo_msgs/GetLinkProperties";

            Property args : string = "link_name	";

            Property name : string = "get_link_properties";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }
        Port serport1 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "gazebo_msgs/ApplyBodyWrench";

            Property args : string = "body_name	reference_frame	reference_point	wrench	start_time	duration	";

            Property name : string = "apply_body_wrench";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }
        Port serport2 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "gazebo_msgs/GetModelProperties";

            Property args : string = "model_name	";

            Property name : string = "get_model_properties";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }
        Port serport3 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "gazebo_msgs/GetWorldProperties";

            Property args : string = "	";

            Property name : string = "get_world_properties";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }
        Port serport4 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "gazebo_msgs/SpawnModel";

            Property args : string = "model_name	model_xml	robot_namespace	initial_pose	reference_frame	";

            Property name : string = "spawn_gazebo_model";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }
        Port serport5 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "gazebo_msgs/SetJointProperties";

            Property args : string = "joint_name	ode_joint_config	";

            Property name : string = "set_joint_properties";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }
        Port serport6 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "gazebo_msgs/GetModelState";

            Property args : string = "model_name	relative_entity_name	";

            Property name : string = "get_model_state";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }
        Port serport7 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "std_srvs/Empty";

            Property args : string = "	";

            Property name : string = "unpause_physics";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }
        Port serport8 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "gazebo_msgs/JointRequest";

            Property args : string = "joint_name	";

            Property name : string = "clear_joint_forces";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }
        Port serport9 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "gazebo_msgs/SetLinkProperties";

            Property args : string = "link_name	com	gravity_mode	mass	ixx	ixy	ixz	iyy	iyz	izz	";

            Property name : string = "set_link_properties";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }
        Port serport10 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "std_srvs/Empty";

            Property args : string = "	";

            Property name : string = "pause_physics";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }
        Port serport11 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "std_srvs/Empty";

            Property args : string = "	";

            Property name : string = "reset_world";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }
        Port serport12 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "std_srvs/Empty";

            Property args : string = "	";

            Property name : string = "reset_simulation";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }
        Port serport13 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "gazebo_msgs/SetLinkState";

            Property args : string = "link_state	";

            Property name : string = "set_link_state";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }
        Port serport14 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "gazebo_msgs/SpawnModel";

            Property args : string = "model_name	model_xml	robot_namespace	initial_pose	reference_frame	";

            Property name : string = "spawn_urdf_model";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }
        Port serport15 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "gazebo_msgs/GetLinkState";

            Property args : string = "link_name	reference_frame	";

            Property name : string = "get_link_state";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }
        Port serport16 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "gazebo_msgs/SetPhysicsProperties";

            Property args : string = "time_step	max_update_rate	gravity	ode_config	";

            Property name : string = "set_physics_properties";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }
        Port serport17 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "gazebo_msgs/SpawnModel";

            Property args : string = "model_name	model_xml	robot_namespace	initial_pose	reference_frame	";

            Property name : string = "spawn_sdf_model";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }
        Port serport18 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "gazebo_msgs/BodyRequest";

            Property args : string = "body_name	";

            Property name : string = "clear_body_wrenches";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }
        Port serport19 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "gazebo_msgs/SetModelConfiguration";

            Property args : string = "model_name	urdf_param_name	joint_names	joint_positions	";

            Property name : string = "set_model_configuration";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }
        Port serport20 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "roscpp/GetLoggers";

            Property args : string = "	";

            Property name : string = "get_loggers";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }
        Port serport21 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "gazebo_msgs/GetPhysicsProperties";

            Property args : string = "	";

            Property name : string = "get_physics_properties";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }
        Port serport22 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "gazebo_msgs/ApplyJointEffort";

            Property args : string = "joint_name	effort	start_time	duration	";

            Property name : string = "apply_joint_effort";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }
        Port serport23 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "gazebo_msgs/GetJointProperties";

            Property args : string = "joint_name	";

            Property name : string = "get_joint_properties";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }
        Port serport24 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "gazebo_msgs/DeleteModel";

            Property args : string = "model_name	";

            Property name : string = "delete_model";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }
        Port serport25 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "dynamic_reconfigure/Reconfigure";

            Property args : string = "config	";

            Property name : string = "set_parameters";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }
        Port serport26 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "roscpp/SetLoggerLevel";

            Property args : string = "logger	level	";

            Property name : string = "set_logger_level";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }
        Port serport27 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "gazebo_msgs/SetModelState";

            Property args : string = "model_state	";

            Property name : string = "set_model_state";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }

        Property name : string = "/gazebo";
        rule noServiceCallToSelf = invariant forall req :! ServiceClientPortT in self.PORTS | 
             ! exists resp :! ServiceProviderPortT in self.PORTS | 
                connected(req, resp);
        rule noActionCalLToSelf = invariant forall req :! ActionClientPortT in self.PORTS | 
             ! exists resp :! ActionServerPortT in self.PORTS | 
                connected(req, resp);

    }
    Component __laserscan_nodelet_managernode : ROSNodeManagerCompT = new ROSNodeManagerCompT extended with {
        Port serport0 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "roscpp/GetLoggers";

            Property args : string = "	";

            Property name : string = "get_loggers";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }
        Port serport1 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "roscpp/SetLoggerLevel";

            Property args : string = "logger	level	";

            Property name : string = "set_logger_level";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }
        Port serport2 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "nodelet/NodeletLoad";

            Property args : string = "name	type	remap_source_args	remap_target_args	my_argv	bond_id	";

            Property name : string = "load_nodelet";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }
        Port serport3 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "nodelet/NodeletList";

            Property args : string = "	";

            Property name : string = "list";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }
        Port serport4 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "nodelet/NodeletUnload";

            Property args : string = "name	";

            Property name : string = "unload_nodelet";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }

        Property name : string = "/laserscan_nodelet_manager";
        rule noServiceCallToSelf = invariant forall req :! ServiceClientPortT in self.PORTS | 
             ! exists resp :! ServiceProviderPortT in self.PORTS | 
                connected(req, resp);
        rule noActionCalLToSelf = invariant forall req :! ActionClientPortT in self.PORTS | 
             ! exists resp :! ActionServerPortT in self.PORTS | 
                connected(req, resp);

    }
    Component __depthimage_to_laserscannode : ROSNodeletCompT = new ROSNodeletCompT extended with {
        Port serport0 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "dynamic_reconfigure/Reconfigure";

            Property args : string = "config	";

            Property name : string = "set_parameters";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }
        Port serport1 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "roscpp/SetLoggerLevel";

            Property args : string = "logger	level	";

            Property name : string = "set_logger_level";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }
        Port serport2 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "roscpp/GetLoggers";

            Property args : string = "	";

            Property name : string = "get_loggers";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }

        Property name : string = "/depthimage_to_laserscan";
        rule noServiceCallToSelf = invariant forall req :! ServiceClientPortT in self.PORTS | 
             ! exists resp :! ServiceProviderPortT in self.PORTS | 
                connected(req, resp);
        rule noActionCalLToSelf = invariant forall req :! ActionClientPortT in self.PORTS | 
             ! exists resp :! ActionServerPortT in self.PORTS | 
                connected(req, resp);

    }
    Component __mobile_base_nodelet_managernode : ROSNodeManagerCompT = new ROSNodeManagerCompT extended with {
        Port serport0 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "roscpp/GetLoggers";

            Property args : string = "	";

            Property name : string = "get_loggers";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }
        Port serport1 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "nodelet/NodeletUnload";

            Property args : string = "name	";

            Property name : string = "unload_nodelet";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }
        Port serport2 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "nodelet/NodeletList";

            Property args : string = "	";

            Property name : string = "list";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }
        Port serport3 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "nodelet/NodeletLoad";

            Property args : string = "name	type	remap_source_args	remap_target_args	my_argv	bond_id	";

            Property name : string = "load_nodelet";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }
        Port serport4 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "roscpp/SetLoggerLevel";

            Property args : string = "logger	level	";

            Property name : string = "set_logger_level";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }

        Property name : string = "/mobile_base_nodelet_manager";
        rule noServiceCallToSelf = invariant forall req :! ServiceClientPortT in self.PORTS | 
             ! exists resp :! ServiceProviderPortT in self.PORTS | 
                connected(req, resp);
        rule noActionCalLToSelf = invariant forall req :! ActionClientPortT in self.PORTS | 
             ! exists resp :! ActionServerPortT in self.PORTS | 
                connected(req, resp);

    }
    Component __bumper2pointcloudnode : ROSNodeletCompT = new ROSNodeletCompT extended with {
        Port serport0 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "roscpp/SetLoggerLevel";

            Property args : string = "logger	level	";

            Property name : string = "set_logger_level";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }
        Port serport1 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "roscpp/GetLoggers";

            Property args : string = "	";

            Property name : string = "get_loggers";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }

        Property name : string = "/bumper2pointcloud";
        rule noServiceCallToSelf = invariant forall req :! ServiceClientPortT in self.PORTS | 
             ! exists resp :! ServiceProviderPortT in self.PORTS | 
                connected(req, resp);
        rule noActionCalLToSelf = invariant forall req :! ActionClientPortT in self.PORTS | 
             ! exists resp :! ActionServerPortT in self.PORTS | 
                connected(req, resp);

    }
    Component __cmd_vel_muxnode : ROSNodeletCompT = new ROSNodeletCompT extended with {
        Port serport0 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "roscpp/SetLoggerLevel";

            Property args : string = "logger	level	";

            Property name : string = "set_logger_level";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }
        Port serport1 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "dynamic_reconfigure/Reconfigure";

            Property args : string = "config	";

            Property name : string = "set_parameters";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }
        Port serport2 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "roscpp/GetLoggers";

            Property args : string = "	";

            Property name : string = "get_loggers";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }

        Property name : string = "/cmd_vel_mux";
        rule noServiceCallToSelf = invariant forall req :! ServiceClientPortT in self.PORTS | 
             ! exists resp :! ServiceProviderPortT in self.PORTS | 
                connected(req, resp);
        rule noActionCalLToSelf = invariant forall req :! ActionClientPortT in self.PORTS | 
             ! exists resp :! ActionServerPortT in self.PORTS | 
                connected(req, resp);

    }
    Component __kobuki_safety_controllernode : ROSNodeletCompT = new ROSNodeletCompT extended with {
        Port serport0 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "roscpp/GetLoggers";

            Property args : string = "	";

            Property name : string = "get_loggers";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }
        Port serport1 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "roscpp/SetLoggerLevel";

            Property args : string = "logger	level	";

            Property name : string = "set_logger_level";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }

        Property name : string = "/kobuki_safety_controller";
        rule noServiceCallToSelf = invariant forall req :! ServiceClientPortT in self.PORTS | 
             ! exists resp :! ServiceProviderPortT in self.PORTS | 
                connected(req, resp);
        rule noActionCalLToSelf = invariant forall req :! ActionClientPortT in self.PORTS | 
             ! exists resp :! ActionServerPortT in self.PORTS | 
                connected(req, resp);

    }
    Component __navigation_velocity_smoothernode : ROSNodeletCompT = new ROSNodeletCompT extended with {
        Port serport0 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "dynamic_reconfigure/Reconfigure";

            Property args : string = "config	";

            Property name : string = "set_parameters";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }
        Port serport1 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "roscpp/SetLoggerLevel";

            Property args : string = "logger	level	";

            Property name : string = "set_logger_level";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }
        Port serport2 : ServiceProviderPortT = new ServiceProviderPortT extended with {

            Property svc_type : string = "roscpp/GetLoggers";

            Property args : string = "	";

            Property name : string = "get_loggers";
            rule atLeast1Attachment = heuristic size(self.ATTACHEDROLES) >= 1;
            rule attachedOnlyToReponderRoleT = invariant forall r in self.ATTACHEDROLES | 
                declaresType(r, ResponderRoleT);

        }

        Property name : string = "/navigation_velocity_smoother";
        rule noServiceCallToSelf = invariant forall req :! ServiceClientPortT in self.PORTS | 
             ! exists resp :! ServiceProviderPortT in self.PORTS | 
                connected(req, resp);
        rule noActionCalLToSelf = invariant forall req :! ActionClientPortT in self.PORTS | 
             ! exists resp :! ActionServerPortT in self.PORTS | 
                connected(req, resp);

    }
    Connector __move_base__local_costmap__parameter_descriptionstopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicAdvertiserRoleT0 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/move_base/local_costmap/parameter_descriptions";

        Property msg_type : string = "dynamic_reconfigure/ConfigDescription";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __mobile_base__events__clifftopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicAdvertiserRoleT9 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/mobile_base/events/cliff";

        Property msg_type : string = "kobuki_msgs/CliffEvent";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __move_base__local_costmap__costmaptopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicSubscriberRoleT1 : ROSTopicSubscriberRoleT = new ROSTopicSubscriberRoleT extended with {
            rule attachedOnlyToReceivePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, ReceivePortT);
            rule attachedToSubscribePortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, SubscribePortT);

        }
        Role ROSTopicAdvertiserRoleT0 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/move_base/local_costmap/costmap";

        Property msg_type : string = "nav_msgs/OccupancyGrid";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __move_base__global_costmap__obstacle_layer__clearing_endpointstopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicAdvertiserRoleT0 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/move_base/global_costmap/obstacle_layer/clearing_endpoints";

        Property msg_type : string = "sensor_msgs/PointCloud";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __move_base__local_costmap__obstacle_layer__parameter_descriptionstopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicAdvertiserRoleT6 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/move_base/local_costmap/obstacle_layer/parameter_descriptions";

        Property msg_type : string = "dynamic_reconfigure/ConfigDescription";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __camera__depth__pointstopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicAdvertiserRoleT0 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/camera/depth/points";

        Property msg_type : string = "sensor_msgs/PointCloud2";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __maptopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicSubscriberRoleT4 : ROSTopicSubscriberRoleT = new ROSTopicSubscriberRoleT extended with {
            rule attachedOnlyToReceivePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, ReceivePortT);
            rule attachedToSubscribePortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, SubscribePortT);

        }
        Role ROSTopicAdvertiserRoleT4 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }
        Role ROSTopicSubscriberRoleT7 : ROSTopicSubscriberRoleT = new ROSTopicSubscriberRoleT extended with {
            rule attachedOnlyToReceivePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, ReceivePortT);
            rule attachedToSubscribePortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, SubscribePortT);

        }

        Property topic : string = "/map";

        Property msg_type : string = "nav_msgs/OccupancyGrid";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __clocktopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicSubscriberRoleT0 : ROSTopicSubscriberRoleT = new ROSTopicSubscriberRoleT extended with {
            rule attachedOnlyToReceivePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, ReceivePortT);
            rule attachedToSubscribePortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, SubscribePortT);

        }
        Role ROSTopicSubscriberRoleT1 : ROSTopicSubscriberRoleT = new ROSTopicSubscriberRoleT extended with {
            rule attachedOnlyToReceivePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, ReceivePortT);
            rule attachedToSubscribePortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, SubscribePortT);

        }
        Role ROSTopicSubscriberRoleT2 : ROSTopicSubscriberRoleT = new ROSTopicSubscriberRoleT extended with {
            rule attachedOnlyToReceivePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, ReceivePortT);
            rule attachedToSubscribePortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, SubscribePortT);

        }
        Role ROSTopicSubscriberRoleT3 : ROSTopicSubscriberRoleT = new ROSTopicSubscriberRoleT extended with {
            rule attachedOnlyToReceivePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, ReceivePortT);
            rule attachedToSubscribePortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, SubscribePortT);

        }
        Role ROSTopicSubscriberRoleT4 : ROSTopicSubscriberRoleT = new ROSTopicSubscriberRoleT extended with {
            rule attachedOnlyToReceivePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, ReceivePortT);
            rule attachedToSubscribePortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, SubscribePortT);

        }
        Role ROSTopicSubscriberRoleT5 : ROSTopicSubscriberRoleT = new ROSTopicSubscriberRoleT extended with {
            rule attachedOnlyToReceivePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, ReceivePortT);
            rule attachedToSubscribePortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, SubscribePortT);

        }
        Role ROSTopicSubscriberRoleT6 : ROSTopicSubscriberRoleT = new ROSTopicSubscriberRoleT extended with {
            rule attachedOnlyToReceivePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, ReceivePortT);
            rule attachedToSubscribePortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, SubscribePortT);

        }
        Role ROSTopicSubscriberRoleT7 : ROSTopicSubscriberRoleT = new ROSTopicSubscriberRoleT extended with {
            rule attachedOnlyToReceivePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, ReceivePortT);
            rule attachedToSubscribePortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, SubscribePortT);

        }
        Role ROSTopicSubscriberRoleT8 : ROSTopicSubscriberRoleT = new ROSTopicSubscriberRoleT extended with {
            rule attachedOnlyToReceivePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, ReceivePortT);
            rule attachedToSubscribePortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, SubscribePortT);

        }
        Role ROSTopicSubscriberRoleT9 : ROSTopicSubscriberRoleT = new ROSTopicSubscriberRoleT extended with {
            rule attachedOnlyToReceivePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, ReceivePortT);
            rule attachedToSubscribePortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, SubscribePortT);

        }
        Role ROSTopicSubscriberRoleT10 : ROSTopicSubscriberRoleT = new ROSTopicSubscriberRoleT extended with {
            rule attachedOnlyToReceivePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, ReceivePortT);
            rule attachedToSubscribePortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, SubscribePortT);

        }
        Role ROSTopicAdvertiserRoleT9 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/clock";

        Property msg_type : string = "rosgraph_msgs/Clock";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __camera__rgb__image_raw__theora__parameter_updatestopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicAdvertiserRoleT9 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/camera/rgb/image_raw/theora/parameter_updates";

        Property msg_type : string = "dynamic_reconfigure/Config";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __camera__rgb__image_raw__compressedDepth__parameter_descriptionstopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicAdvertiserRoleT0 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/camera/rgb/image_raw/compressedDepth/parameter_descriptions";

        Property msg_type : string = "dynamic_reconfigure/ConfigDescription";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __move_base__local_costmap__inflation_layer__parameter_descriptionstopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicAdvertiserRoleT0 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/move_base/local_costmap/inflation_layer/parameter_descriptions";

        Property msg_type : string = "dynamic_reconfigure/ConfigDescription";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __move_base__global_costmap__costmaptopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicSubscriberRoleT1 : ROSTopicSubscriberRoleT = new ROSTopicSubscriberRoleT extended with {
            rule attachedOnlyToReceivePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, ReceivePortT);
            rule attachedToSubscribePortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, SubscribePortT);

        }
        Role ROSTopicAdvertiserRoleT6 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/move_base/global_costmap/costmap";

        Property msg_type : string = "nav_msgs/OccupancyGrid";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __rosouttopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicAdvertiserRoleT0 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }
        Role ROSTopicAdvertiserRoleT1 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }
        Role ROSTopicAdvertiserRoleT2 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }
        Role ROSTopicSubscriberRoleT0 : ROSTopicSubscriberRoleT = new ROSTopicSubscriberRoleT extended with {
            rule attachedOnlyToReceivePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, ReceivePortT);
            rule attachedToSubscribePortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, SubscribePortT);

        }
        Role ROSTopicAdvertiserRoleT3 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }
        Role ROSTopicAdvertiserRoleT4 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }
        Role ROSTopicAdvertiserRoleT5 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }
        Role ROSTopicAdvertiserRoleT6 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }
        Role ROSTopicAdvertiserRoleT7 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }
        Role ROSTopicAdvertiserRoleT8 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }
        Role ROSTopicAdvertiserRoleT9 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/rosout";

        Property msg_type : string = "rosgraph_msgs/Log";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __joint_statestopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicSubscriberRoleT0 : ROSTopicSubscriberRoleT = new ROSTopicSubscriberRoleT extended with {
            rule attachedOnlyToReceivePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, ReceivePortT);
            rule attachedToSubscribePortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, SubscribePortT);

        }
        Role ROSTopicAdvertiserRoleT2 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/joint_states";

        Property msg_type : string = "sensor_msgs/JointState";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __move_base__NavfnROS__plantopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicSubscriberRoleT1 : ROSTopicSubscriberRoleT = new ROSTopicSubscriberRoleT extended with {
            rule attachedOnlyToReceivePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, ReceivePortT);
            rule attachedToSubscribePortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, SubscribePortT);

        }
        Role ROSTopicAdvertiserRoleT0 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/move_base/NavfnROS/plan";

        Property msg_type : string = "nav_msgs/Path";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __particlecloudtopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicAdvertiserRoleT0 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }
        Role ROSTopicSubscriberRoleT1 : ROSTopicSubscriberRoleT = new ROSTopicSubscriberRoleT extended with {
            rule attachedOnlyToReceivePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, ReceivePortT);
            rule attachedToSubscribePortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, SubscribePortT);

        }

        Property topic : string = "/particlecloud";

        Property msg_type : string = "geometry_msgs/PoseArray";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __ig_action_server__resulttopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicAdvertiserRoleT0 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }
        Role ROSTopicSubscriberRoleT0 : ROSTopicSubscriberRoleT = new ROSTopicSubscriberRoleT extended with {
            rule attachedOnlyToReceivePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, ReceivePortT);
            rule attachedToSubscribePortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, SubscribePortT);

        }

        Property topic : string = "/ig_action_server/result";

        Property msg_type : string = "ig_action_msgs/InstructionGraphActionResult";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __move_base__global_costmap__obstacle_layer__parameter_updatestopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicAdvertiserRoleT0 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/move_base/global_costmap/obstacle_layer/parameter_updates";

        Property msg_type : string = "dynamic_reconfigure/Config";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __camera__rgb__image_raw__theora__parameter_descriptionstopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicAdvertiserRoleT0 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/camera/rgb/image_raw/theora/parameter_descriptions";

        Property msg_type : string = "dynamic_reconfigure/ConfigDescription";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __move_base__local_costmap__parameter_updatestopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicAdvertiserRoleT0 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/move_base/local_costmap/parameter_updates";

        Property msg_type : string = "dynamic_reconfigure/Config";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __move_base__local_costmap__costmap_updatestopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicSubscriberRoleT1 : ROSTopicSubscriberRoleT = new ROSTopicSubscriberRoleT extended with {
            rule attachedOnlyToReceivePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, ReceivePortT);
            rule attachedToSubscribePortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, SubscribePortT);

        }
        Role ROSTopicAdvertiserRoleT0 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/move_base/local_costmap/costmap_updates";

        Property msg_type : string = "map_msgs/OccupancyGridUpdate";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __amcl__parameter_updatestopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicAdvertiserRoleT0 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/amcl/parameter_updates";

        Property msg_type : string = "dynamic_reconfigure/Config";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __cmd_vel_mux__parameter_updatestopic : TopicConnectorT = new TopicConnectorT extended with {

        Property topic : string = "/cmd_vel_mux/parameter_updates";

        Property msg_type : string = "dynamic_reconfigure/Config";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __camera__rgb__image_raw__compressed__parameter_descriptionstopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicAdvertiserRoleT0 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/camera/rgb/image_raw/compressed/parameter_descriptions";

        Property msg_type : string = "dynamic_reconfigure/ConfigDescription";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __mobile_base__sensors__bumper_pointcloudtopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicSubscriberRoleT1 : ROSTopicSubscriberRoleT = new ROSTopicSubscriberRoleT extended with {
            rule attachedOnlyToReceivePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, ReceivePortT);
            rule attachedToSubscribePortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, SubscribePortT);

        }
        Role ROSTopicSubscriberRoleT2 : ROSTopicSubscriberRoleT = new ROSTopicSubscriberRoleT extended with {
            rule attachedOnlyToReceivePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, ReceivePortT);
            rule attachedToSubscribePortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, SubscribePortT);

        }

        Property topic : string = "/mobile_base/sensors/bumper_pointcloud";

        Property msg_type : string = "sensor_msgs/PointCloud2";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __depthimage_to_laserscan__parameter_updatestopic : TopicConnectorT = new TopicConnectorT extended with {

        Property topic : string = "/depthimage_to_laserscan/parameter_updates";

        Property msg_type : string = "dynamic_reconfigure/Config";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __move_base__DWAPlannerROS__cost_cloudtopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicSubscriberRoleT1 : ROSTopicSubscriberRoleT = new ROSTopicSubscriberRoleT extended with {
            rule attachedOnlyToReceivePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, ReceivePortT);
            rule attachedToSubscribePortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, SubscribePortT);

        }
        Role ROSTopicAdvertiserRoleT0 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/move_base/DWAPlannerROS/cost_cloud";

        Property msg_type : string = "sensor_msgs/PointCloud2";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __navigation_velocity_smoother__parameter_descriptionstopic : TopicConnectorT = new TopicConnectorT extended with {

        Property topic : string = "/navigation_velocity_smoother/parameter_descriptions";

        Property msg_type : string = "dynamic_reconfigure/ConfigDescription";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __move_base__global_costmap__inflation_layer__parameter_updatestopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicAdvertiserRoleT0 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/move_base/global_costmap/inflation_layer/parameter_updates";

        Property msg_type : string = "dynamic_reconfigure/Config";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __move_base__parameter_descriptionstopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicAdvertiserRoleT6 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/move_base/parameter_descriptions";

        Property msg_type : string = "dynamic_reconfigure/ConfigDescription";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __camera__rgb__image_raw__compressed__parameter_updatestopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicAdvertiserRoleT2 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/camera/rgb/image_raw/compressed/parameter_updates";

        Property msg_type : string = "dynamic_reconfigure/Config";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __move_base__parameter_updatestopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicAdvertiserRoleT0 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/move_base/parameter_updates";

        Property msg_type : string = "dynamic_reconfigure/Config";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __move_base__local_costmap__obstacle_layer__clearing_endpointstopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicAdvertiserRoleT6 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/move_base/local_costmap/obstacle_layer/clearing_endpoints";

        Property msg_type : string = "sensor_msgs/PointCloud";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __cmd_vel_mux__activetopic : TopicConnectorT = new TopicConnectorT extended with {

        Property topic : string = "/cmd_vel_mux/active";

        Property msg_type : string = "std_msgs/String";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __move_base__local_costmap__obstacle_layer__parameter_updatestopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicAdvertiserRoleT0 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/move_base/local_costmap/obstacle_layer/parameter_updates";

        Property msg_type : string = "dynamic_reconfigure/Config";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __map_metadatatopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicAdvertiserRoleT0 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/map_metadata";

        Property msg_type : string = "nav_msgs/MapMetaData";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __tftopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicSubscriberRoleT0 : ROSTopicSubscriberRoleT = new ROSTopicSubscriberRoleT extended with {
            rule attachedOnlyToReceivePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, ReceivePortT);
            rule attachedToSubscribePortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, SubscribePortT);

        }
        Role ROSTopicAdvertiserRoleT0 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }
        Role ROSTopicAdvertiserRoleT1 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }
        Role ROSTopicSubscriberRoleT1 : ROSTopicSubscriberRoleT = new ROSTopicSubscriberRoleT extended with {
            rule attachedOnlyToReceivePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, ReceivePortT);
            rule attachedToSubscribePortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, SubscribePortT);

        }
        Role ROSTopicSubscriberRoleT2 : ROSTopicSubscriberRoleT = new ROSTopicSubscriberRoleT extended with {
            rule attachedOnlyToReceivePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, ReceivePortT);
            rule attachedToSubscribePortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, SubscribePortT);

        }
        Role ROSTopicAdvertiserRoleT2 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/tf";

        Property msg_type : string = "tf2_msgs/TFMessage";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __move_base__global_costmap__inflation_layer__parameter_descriptionstopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicAdvertiserRoleT0 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/move_base/global_costmap/inflation_layer/parameter_descriptions";

        Property msg_type : string = "dynamic_reconfigure/ConfigDescription";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __rosout_aggtopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicAdvertiserRoleT0 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/rosout_agg";

        Property msg_type : string = "rosgraph_msgs/Log";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __ig_action_server__statustopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicAdvertiserRoleT0 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }
        Role ROSTopicSubscriberRoleT0 : ROSTopicSubscriberRoleT = new ROSTopicSubscriberRoleT extended with {
            rule attachedOnlyToReceivePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, ReceivePortT);
            rule attachedToSubscribePortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, SubscribePortT);

        }

        Property topic : string = "/ig_action_server/status";

        Property msg_type : string = "actionlib_msgs/GoalStatusArray";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __navigation_velocity_smoother__raw_cmd_veltopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicAdvertiserRoleT0 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/navigation_velocity_smoother/raw_cmd_vel";

        Property msg_type : string = "geometry_msgs/Twist";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __camera__depth__camera_infotopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicAdvertiserRoleT9 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/camera/depth/camera_info";

        Property msg_type : string = "sensor_msgs/CameraInfo";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __navigation_velocity_smoother__parameter_updatestopic : TopicConnectorT = new TopicConnectorT extended with {

        Property topic : string = "/navigation_velocity_smoother/parameter_updates";

        Property msg_type : string = "dynamic_reconfigure/Config";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __camera__rgb__image_raw__compressedDepthtopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicAdvertiserRoleT0 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/camera/rgb/image_raw/compressedDepth";

        Property msg_type : string = "sensor_msgs/CompressedImage";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __euler_orientationtopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicAdvertiserRoleT0 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }
        Role ROSTopicSubscriberRoleT0 : ROSTopicSubscriberRoleT = new ROSTopicSubscriberRoleT extended with {
            rule attachedOnlyToReceivePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, ReceivePortT);
            rule attachedToSubscribePortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, SubscribePortT);

        }

        Property topic : string = "/euler_orientation";

        Property msg_type : string = "messages/euler";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __camera__parameter_descriptionstopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicAdvertiserRoleT0 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/camera/parameter_descriptions";

        Property msg_type : string = "dynamic_reconfigure/ConfigDescription";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __gazebo__model_statestopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicAdvertiserRoleT0 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/gazebo/model_states";

        Property msg_type : string = "gazebo_msgs/ModelStates";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __ig_action_server__feedbacktopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicAdvertiserRoleT0 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }
        Role ROSTopicSubscriberRoleT0 : ROSTopicSubscriberRoleT = new ROSTopicSubscriberRoleT extended with {
            rule attachedOnlyToReceivePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, ReceivePortT);
            rule attachedToSubscribePortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, SubscribePortT);

        }

        Property topic : string = "/ig_action_server/feedback";

        Property msg_type : string = "ig_action_msgs/InstructionGraphActionFeedback";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __camera__rgb__image_raw__compressedDepth__parameter_updatestopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicAdvertiserRoleT0 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/camera/rgb/image_raw/compressedDepth/parameter_updates";

        Property msg_type : string = "dynamic_reconfigure/Config";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __move_base__DWAPlannerROS__local_plantopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicSubscriberRoleT4 : ROSTopicSubscriberRoleT = new ROSTopicSubscriberRoleT extended with {
            rule attachedOnlyToReceivePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, ReceivePortT);
            rule attachedToSubscribePortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, SubscribePortT);

        }
        Role ROSTopicAdvertiserRoleT6 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/move_base/DWAPlannerROS/local_plan";

        Property msg_type : string = "nav_msgs/Path";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __move_base_simple__goaltopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicAdvertiserRoleT3 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }
        Role ROSTopicSubscriberRoleT2 : ROSTopicSubscriberRoleT = new ROSTopicSubscriberRoleT extended with {
            rule attachedOnlyToReceivePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, ReceivePortT);
            rule attachedToSubscribePortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, SubscribePortT);

        }

        Property topic : string = "/move_base_simple/goal";

        Property msg_type : string = "geometry_msgs/PoseStamped";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __camera__depth__image_rawtopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicAdvertiserRoleT9 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/camera/depth/image_raw";

        Property msg_type : string = "sensor_msgs/Image";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __move_base__global_costmap__static_layer__parameter_descriptionstopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicAdvertiserRoleT6 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/move_base/global_costmap/static_layer/parameter_descriptions";

        Property msg_type : string = "dynamic_reconfigure/ConfigDescription";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __gazebo__parameter_descriptionstopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicAdvertiserRoleT0 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/gazebo/parameter_descriptions";

        Property msg_type : string = "dynamic_reconfigure/ConfigDescription";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __camera__parameter_updatestopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicAdvertiserRoleT2 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/camera/parameter_updates";

        Property msg_type : string = "dynamic_reconfigure/Config";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __ig_action_server__canceltopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicSubscriberRoleT8 : ROSTopicSubscriberRoleT = new ROSTopicSubscriberRoleT extended with {
            rule attachedOnlyToReceivePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, ReceivePortT);
            rule attachedToSubscribePortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, SubscribePortT);

        }
        Role ROSTopicAdvertiserRoleT8 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/ig_action_server/cancel";

        Property msg_type : string = "actionlib_msgs/GoalID";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __amcl_posetopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicAdvertiserRoleT0 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/amcl_pose";

        Property msg_type : string = "geometry_msgs/PoseWithCovarianceStamped";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __move_base__canceltopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicSubscriberRoleT2 : ROSTopicSubscriberRoleT = new ROSTopicSubscriberRoleT extended with {
            rule attachedOnlyToReceivePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, ReceivePortT);
            rule attachedToSubscribePortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, SubscribePortT);

        }
        Role ROSTopicAdvertiserRoleT7 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/move_base/cancel";

        Property msg_type : string = "actionlib_msgs/GoalID";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __move_base__current_goaltopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicAdvertiserRoleT0 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/move_base/current_goal";

        Property msg_type : string = "geometry_msgs/PoseStamped";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __camera__rgb__image_rawtopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicAdvertiserRoleT0 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/camera/rgb/image_raw";

        Property msg_type : string = "sensor_msgs/Image";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __move_base__DWAPlannerROS__global_plantopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicSubscriberRoleT1 : ROSTopicSubscriberRoleT = new ROSTopicSubscriberRoleT extended with {
            rule attachedOnlyToReceivePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, ReceivePortT);
            rule attachedToSubscribePortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, SubscribePortT);

        }
        Role ROSTopicAdvertiserRoleT0 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/move_base/DWAPlannerROS/global_plan";

        Property msg_type : string = "nav_msgs/Path";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __move_base__local_costmap__footprinttopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicSubscriberRoleT0 : ROSTopicSubscriberRoleT = new ROSTopicSubscriberRoleT extended with {
            rule attachedOnlyToReceivePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, ReceivePortT);
            rule attachedToSubscribePortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, SubscribePortT);

        }
        Role ROSTopicAdvertiserRoleT0 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/move_base/local_costmap/footprint";

        Property msg_type : string = "geometry_msgs/PolygonStamped";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __mobile_base__commands__velocitytopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicSubscriberRoleT0 : ROSTopicSubscriberRoleT = new ROSTopicSubscriberRoleT extended with {
            rule attachedOnlyToReceivePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, ReceivePortT);
            rule attachedToSubscribePortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, SubscribePortT);

        }

        Property topic : string = "/mobile_base/commands/velocity";

        Property msg_type : string = "geometry_msgs/Twist";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __depthimage_to_laserscan__parameter_descriptionstopic : TopicConnectorT = new TopicConnectorT extended with {

        Property topic : string = "/depthimage_to_laserscan/parameter_descriptions";

        Property msg_type : string = "dynamic_reconfigure/ConfigDescription";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __move_base__resulttopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicAdvertiserRoleT6 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }
        Role ROSTopicSubscriberRoleT8 : ROSTopicSubscriberRoleT = new ROSTopicSubscriberRoleT extended with {
            rule attachedOnlyToReceivePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, ReceivePortT);
            rule attachedToSubscribePortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, SubscribePortT);

        }

        Property topic : string = "/move_base/result";

        Property msg_type : string = "move_base_msgs/MoveBaseActionResult";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __mobile_base_nodelet_manager__bondtopic : TopicConnectorT = new TopicConnectorT extended with {

        Property topic : string = "/mobile_base_nodelet_manager/bond";

        Property msg_type : string = "bond/Status";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __amcl__parameter_descriptionstopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicAdvertiserRoleT0 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/amcl/parameter_descriptions";

        Property msg_type : string = "dynamic_reconfigure/ConfigDescription";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __gazebo__parameter_updatestopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicAdvertiserRoleT9 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/gazebo/parameter_updates";

        Property msg_type : string = "dynamic_reconfigure/Config";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __cmd_vel_mux__input__safety_controllertopic : TopicConnectorT = new TopicConnectorT extended with {

        Property topic : string = "/cmd_vel_mux/input/safety_controller";

        Property msg_type : string = "geometry_msgs/Twist";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __mobile_base__sensors__imu_datatopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicAdvertiserRoleT0 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/mobile_base/sensors/imu_data";

        Property msg_type : string = "sensor_msgs/Imu";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __move_base__local_costmap__inflation_layer__parameter_updatestopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicAdvertiserRoleT0 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/move_base/local_costmap/inflation_layer/parameter_updates";

        Property msg_type : string = "dynamic_reconfigure/Config";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __move_base__global_costmap__parameter_updatestopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicAdvertiserRoleT6 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/move_base/global_costmap/parameter_updates";

        Property msg_type : string = "dynamic_reconfigure/Config";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __scantopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicSubscriberRoleT0 : ROSTopicSubscriberRoleT = new ROSTopicSubscriberRoleT extended with {
            rule attachedOnlyToReceivePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, ReceivePortT);
            rule attachedToSubscribePortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, SubscribePortT);

        }
        Role ROSTopicSubscriberRoleT1 : ROSTopicSubscriberRoleT = new ROSTopicSubscriberRoleT extended with {
            rule attachedOnlyToReceivePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, ReceivePortT);
            rule attachedToSubscribePortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, SubscribePortT);

        }
        Role ROSTopicSubscriberRoleT2 : ROSTopicSubscriberRoleT = new ROSTopicSubscriberRoleT extended with {
            rule attachedOnlyToReceivePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, ReceivePortT);
            rule attachedToSubscribePortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, SubscribePortT);

        }

        Property topic : string = "/scan";

        Property msg_type : string = "sensor_msgs/LaserScan";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __move_base__global_costmap__parameter_descriptionstopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicAdvertiserRoleT6 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/move_base/global_costmap/parameter_descriptions";

        Property msg_type : string = "dynamic_reconfigure/ConfigDescription";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __instructiongraphs_statustopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicAdvertiserRoleT7 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/instructiongraphs_status";

        Property msg_type : string = "std_msgs/String";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __move_base__DWAPlannerROS__parameter_updatestopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicAdvertiserRoleT6 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/move_base/DWAPlannerROS/parameter_updates";

        Property msg_type : string = "dynamic_reconfigure/Config";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __camera__rgb__image_raw__compressedtopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicAdvertiserRoleT2 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/camera/rgb/image_raw/compressed";

        Property msg_type : string = "sensor_msgs/CompressedImage";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __camera__rgb__camera_infotopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicAdvertiserRoleT0 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/camera/rgb/camera_info";

        Property msg_type : string = "sensor_msgs/CameraInfo";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __move_base__global_costmap__footprinttopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicSubscriberRoleT2 : ROSTopicSubscriberRoleT = new ROSTopicSubscriberRoleT extended with {
            rule attachedOnlyToReceivePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, ReceivePortT);
            rule attachedToSubscribePortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, SubscribePortT);

        }
        Role ROSTopicAdvertiserRoleT0 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/move_base/global_costmap/footprint";

        Property msg_type : string = "geometry_msgs/PolygonStamped";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __move_base__statustopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicAdvertiserRoleT0 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }
        Role ROSTopicSubscriberRoleT0 : ROSTopicSubscriberRoleT = new ROSTopicSubscriberRoleT extended with {
            rule attachedOnlyToReceivePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, ReceivePortT);
            rule attachedToSubscribePortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, SubscribePortT);

        }

        Property topic : string = "/move_base/status";

        Property msg_type : string = "actionlib_msgs/GoalStatusArray";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __odomtopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicSubscriberRoleT0 : ROSTopicSubscriberRoleT = new ROSTopicSubscriberRoleT extended with {
            rule attachedOnlyToReceivePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, ReceivePortT);
            rule attachedToSubscribePortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, SubscribePortT);

        }
        Role ROSTopicSubscriberRoleT2 : ROSTopicSubscriberRoleT = new ROSTopicSubscriberRoleT extended with {
            rule attachedOnlyToReceivePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, ReceivePortT);
            rule attachedToSubscribePortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, SubscribePortT);

        }
        Role ROSTopicAdvertiserRoleT9 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/odom";

        Property msg_type : string = "nav_msgs/Odometry";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __cmd_vel_mux__parameter_descriptionstopic : TopicConnectorT = new TopicConnectorT extended with {

        Property topic : string = "/cmd_vel_mux/parameter_descriptions";

        Property msg_type : string = "dynamic_reconfigure/ConfigDescription";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __move_base__DWAPlannerROS__trajectory_cloudtopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicSubscriberRoleT1 : ROSTopicSubscriberRoleT = new ROSTopicSubscriberRoleT extended with {
            rule attachedOnlyToReceivePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, ReceivePortT);
            rule attachedToSubscribePortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, SubscribePortT);

        }
        Role ROSTopicAdvertiserRoleT0 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/move_base/DWAPlannerROS/trajectory_cloud";

        Property msg_type : string = "sensor_msgs/PointCloud2";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __laserscan_nodelet_manager__bondtopic : TopicConnectorT = new TopicConnectorT extended with {

        Property topic : string = "/laserscan_nodelet_manager/bond";

        Property msg_type : string = "bond/Status";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __move_base__DWAPlannerROS__parameter_descriptionstopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicAdvertiserRoleT0 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/move_base/DWAPlannerROS/parameter_descriptions";

        Property msg_type : string = "dynamic_reconfigure/ConfigDescription";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __instructiongraphs_goaltopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicAdvertiserRoleT7 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/instructiongraphs_goal";

        Property msg_type : string = "std_msgs/String";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __mobile_base__events__bumpertopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicAdvertiserRoleT0 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/mobile_base/events/bumper";

        Property msg_type : string = "kobuki_msgs/BumperEvent";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __initialposetopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicSubscriberRoleT0 : ROSTopicSubscriberRoleT = new ROSTopicSubscriberRoleT extended with {
            rule attachedOnlyToReceivePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, ReceivePortT);
            rule attachedToSubscribePortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, SubscribePortT);

        }
        Role ROSTopicAdvertiserRoleT0 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/initialpose";

        Property msg_type : string = "geometry_msgs/PoseWithCovarianceStamped";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __camera__rgb__image_raw__theoratopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicAdvertiserRoleT9 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/camera/rgb/image_raw/theora";

        Property msg_type : string = "theora_image_transport/Packet";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __tf_statictopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicSubscriberRoleT0 : ROSTopicSubscriberRoleT = new ROSTopicSubscriberRoleT extended with {
            rule attachedOnlyToReceivePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, ReceivePortT);
            rule attachedToSubscribePortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, SubscribePortT);

        }
        Role ROSTopicAdvertiserRoleT1 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }
        Role ROSTopicSubscriberRoleT1 : ROSTopicSubscriberRoleT = new ROSTopicSubscriberRoleT extended with {
            rule attachedOnlyToReceivePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, ReceivePortT);
            rule attachedToSubscribePortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, SubscribePortT);

        }
        Role ROSTopicSubscriberRoleT2 : ROSTopicSubscriberRoleT = new ROSTopicSubscriberRoleT extended with {
            rule attachedOnlyToReceivePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, ReceivePortT);
            rule attachedToSubscribePortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, SubscribePortT);

        }

        Property topic : string = "/tf_static";

        Property msg_type : string = "tf2_msgs/TFMessage";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __gazebo__link_statestopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicAdvertiserRoleT9 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/gazebo/link_states";

        Property msg_type : string = "gazebo_msgs/LinkStates";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __cmd_vel_mux__input__navitopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicAdvertiserRoleT1 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/cmd_vel_mux/input/navi";

        Property msg_type : string = "geometry_msgs/Twist";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __ig_action_server__goaltopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicSubscriberRoleT0 : ROSTopicSubscriberRoleT = new ROSTopicSubscriberRoleT extended with {
            rule attachedOnlyToReceivePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, ReceivePortT);
            rule attachedToSubscribePortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, SubscribePortT);

        }
        Role ROSTopicAdvertiserRoleT0 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/ig_action_server/goal";

        Property msg_type : string = "ig_action_msgs/InstructionGraphActionGoal";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __move_base__feedbacktopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicAdvertiserRoleT0 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }
        Role ROSTopicSubscriberRoleT0 : ROSTopicSubscriberRoleT = new ROSTopicSubscriberRoleT extended with {
            rule attachedOnlyToReceivePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, ReceivePortT);
            rule attachedToSubscribePortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, SubscribePortT);

        }

        Property topic : string = "/move_base/feedback";

        Property msg_type : string = "move_base_msgs/MoveBaseActionFeedback";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __move_base__global_costmap__costmap_updatestopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicSubscriberRoleT1 : ROSTopicSubscriberRoleT = new ROSTopicSubscriberRoleT extended with {
            rule attachedOnlyToReceivePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, ReceivePortT);
            rule attachedToSubscribePortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, SubscribePortT);

        }
        Role ROSTopicAdvertiserRoleT0 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/move_base/global_costmap/costmap_updates";

        Property msg_type : string = "map_msgs/OccupancyGridUpdate";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __move_base__goaltopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicSubscriberRoleT2 : ROSTopicSubscriberRoleT = new ROSTopicSubscriberRoleT extended with {
            rule attachedOnlyToReceivePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, ReceivePortT);
            rule attachedToSubscribePortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, SubscribePortT);

        }
        Role ROSTopicAdvertiserRoleT0 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }
        Role ROSTopicAdvertiserRoleT1 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/move_base/goal";

        Property msg_type : string = "move_base_msgs/MoveBaseActionGoal";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __move_base__global_costmap__static_layer__parameter_updatestopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicAdvertiserRoleT0 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/move_base/global_costmap/static_layer/parameter_updates";

        Property msg_type : string = "dynamic_reconfigure/Config";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __move_base__global_costmap__obstacle_layer__parameter_descriptionstopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicAdvertiserRoleT0 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/move_base/global_costmap/obstacle_layer/parameter_descriptions";

        Property msg_type : string = "dynamic_reconfigure/ConfigDescription";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Connector __clicked_pointtopic : TopicConnectorT = new TopicConnectorT extended with {
        Role ROSTopicAdvertiserRoleT0 : ROSTopicAdvertiserRoleT = new ROSTopicAdvertiserRoleT extended with {
            rule attachedOnlyToAnnouncePortT = invariant forall a in self.ATTACHEDPORTS | 
                declaresType(a, AnnouncePortT);
            rule attachedToPublisherPortT = invariant forall p in self.ATTACHEDPORTS | 
                declaresType(p, PublishPortT);

        }

        Property topic : string = "/clicked_point";

        Property msg_type : string = "geometry_msgs/PointStamped";
        rule topicsMatchAdvertiser = invariant forall r :! ROSTopicAdvertiserRoleT in self.ROLES | 
            forall p :! TopicAdvertisePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule topicsMatchSubscriber = invariant forall r :! ROSTopicSubscriberRoleT in self.ROLES | 
            forall p :! TopicSubscribePortT in r.ATTACHEDPORTS | 
                (p.topic == topic AND p.msg_type == msg_type);
        rule hasOneAnnoucerRole = invariant exists r in self.ROLES | 
            declaresType(r, AnnouncerRoleT);
        rule hasOneReceiverRole = invariant exists r in self.ROLES | 
            declaresType(r, ReceiverRoleT);
        rule atLeast1RoleOfTypePublisherRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, PublisherRoleT);
        rule atLeast1RoleOfTypeSubscriberRoleT = heuristic exists r in self.ROLES | 
            declaresType(r, SubscriberRoleT);

    }
    Attachment __amclnode.sport0 to __scantopic.ROSTopicSubscriberRoleT0;
    Attachment __amclnode.sport1 to __initialposetopic.ROSTopicSubscriberRoleT0;
    Attachment __amclnode.sport2 to __tftopic.ROSTopicSubscriberRoleT0;
    Attachment __amclnode.sport3 to __tf_statictopic.ROSTopicSubscriberRoleT0;
    Attachment __amclnode.sport4 to __clocktopic.ROSTopicSubscriberRoleT0;
    Attachment __amclnode.pport0 to __particlecloudtopic.ROSTopicAdvertiserRoleT0;
    Attachment __amclnode.pport1 to __tftopic.ROSTopicAdvertiserRoleT0;
    Attachment __amclnode.pport2 to __rosouttopic.ROSTopicAdvertiserRoleT0;
    Attachment __amclnode.pport3 to __amcl_posetopic.ROSTopicAdvertiserRoleT0;
    Attachment __amclnode.pport4 to __amcl__parameter_descriptionstopic.ROSTopicAdvertiserRoleT0;
    Attachment __amclnode.pport5 to __amcl__parameter_updatestopic.ROSTopicAdvertiserRoleT0;
    Attachment __handler_9956_1476197144897node.sport0 to __clocktopic.ROSTopicSubscriberRoleT1;
    Attachment __handler_9956_1476197144897node.pport0 to __rosouttopic.ROSTopicAdvertiserRoleT1;
    Attachment __robot_state_publishernode.sport0 to __joint_statestopic.ROSTopicSubscriberRoleT0;
    Attachment __robot_state_publishernode.sport1 to __clocktopic.ROSTopicSubscriberRoleT2;
    Attachment __robot_state_publishernode.pport0 to __tftopic.ROSTopicAdvertiserRoleT1;
    Attachment __robot_state_publishernode.pport1 to __tf_statictopic.ROSTopicAdvertiserRoleT1;
    Attachment __robot_state_publishernode.pport2 to __rosouttopic.ROSTopicAdvertiserRoleT2;
    Attachment __rosoutnode.sport0 to __rosouttopic.ROSTopicSubscriberRoleT0;
    Attachment __rosoutnode.sport1 to __clocktopic.ROSTopicSubscriberRoleT3;
    Attachment __rosoutnode.pport0 to __rosout_aggtopic.ROSTopicAdvertiserRoleT0;
    Attachment __rviznode.sport0 to __scantopic.ROSTopicSubscriberRoleT1;
    Attachment __rviznode.sport1 to __move_base__NavfnROS__plantopic.ROSTopicSubscriberRoleT1;
    Attachment __rviznode.sport2 to __move_base__local_costmap__costmaptopic.ROSTopicSubscriberRoleT1;
    Attachment __rviznode.sport3 to __particlecloudtopic.ROSTopicSubscriberRoleT1;
    Attachment __rviznode.sport4 to __move_base__DWAPlannerROS__global_plantopic.ROSTopicSubscriberRoleT1;
    Attachment __rviznode.sport5 to __move_base__DWAPlannerROS__cost_cloudtopic.ROSTopicSubscriberRoleT1;
    Attachment __rviznode.sport6 to __move_base__global_costmap__costmap_updatestopic.ROSTopicSubscriberRoleT1;
    Attachment __rviznode.sport7 to __tftopic.ROSTopicSubscriberRoleT1;
    Attachment __rviznode.sport8 to __move_base__DWAPlannerROS__trajectory_cloudtopic.ROSTopicSubscriberRoleT1;
    Attachment __rviznode.sport9 to __move_base__local_costmap__costmap_updatestopic.ROSTopicSubscriberRoleT1;
    Attachment __rviznode.sport10 to __tf_statictopic.ROSTopicSubscriberRoleT1;
    Attachment __rviznode.sport11 to __move_base__global_costmap__costmaptopic.ROSTopicSubscriberRoleT1;
    Attachment __rviznode.sport12 to __mobile_base__sensors__bumper_pointcloudtopic.ROSTopicSubscriberRoleT1;
    Attachment __rviznode.sport13 to __clocktopic.ROSTopicSubscriberRoleT4;
    Attachment __rviznode.sport14 to __maptopic.ROSTopicSubscriberRoleT4;
    Attachment __rviznode.sport15 to __move_base__DWAPlannerROS__local_plantopic.ROSTopicSubscriberRoleT4;
    Attachment __rviznode.pport0 to __clicked_pointtopic.ROSTopicAdvertiserRoleT0;
    Attachment __rviznode.pport1 to __initialposetopic.ROSTopicAdvertiserRoleT0;
    Attachment __rviznode.pport2 to __rosouttopic.ROSTopicAdvertiserRoleT3;
    Attachment __rviznode.pport3 to __move_base_simple__goaltopic.ROSTopicAdvertiserRoleT3;
    Attachment __map_servernode.sport0 to __clocktopic.ROSTopicSubscriberRoleT5;
    Attachment __map_servernode.pport0 to __map_metadatatopic.ROSTopicAdvertiserRoleT0;
    Attachment __map_servernode.pport1 to __rosouttopic.ROSTopicAdvertiserRoleT4;
    Attachment __map_servernode.pport2 to __maptopic.ROSTopicAdvertiserRoleT4;
    Attachment __euler_orientationnode.sport0 to __odomtopic.ROSTopicSubscriberRoleT0;
    Attachment __euler_orientationnode.sport1 to __clocktopic.ROSTopicSubscriberRoleT6;
    Attachment __euler_orientationnode.pport0 to __euler_orientationtopic.ROSTopicAdvertiserRoleT0;
    Attachment __euler_orientationnode.pport1 to __rosouttopic.ROSTopicAdvertiserRoleT5;
    Attachment __move_basenode.sport0 to __move_base__local_costmap__footprinttopic.ROSTopicSubscriberRoleT0;
    Attachment __move_basenode.sport1 to __scantopic.ROSTopicSubscriberRoleT2;
    Attachment __move_basenode.sport2 to __move_base__global_costmap__footprinttopic.ROSTopicSubscriberRoleT2;
    Attachment __move_basenode.sport3 to __move_base__goaltopic.ROSTopicSubscriberRoleT2;
    Attachment __move_basenode.sport4 to __tftopic.ROSTopicSubscriberRoleT2;
    Attachment __move_basenode.sport5 to __tf_statictopic.ROSTopicSubscriberRoleT2;
    Attachment __move_basenode.sport6 to __move_base__canceltopic.ROSTopicSubscriberRoleT2;
    Attachment __move_basenode.sport7 to __odomtopic.ROSTopicSubscriberRoleT2;
    Attachment __move_basenode.sport8 to __move_base_simple__goaltopic.ROSTopicSubscriberRoleT2;
    Attachment __move_basenode.sport9 to __mobile_base__sensors__bumper_pointcloudtopic.ROSTopicSubscriberRoleT2;
    Attachment __move_basenode.sport10 to __clocktopic.ROSTopicSubscriberRoleT7;
    Attachment __move_basenode.sport11 to __maptopic.ROSTopicSubscriberRoleT7;
    Attachment __move_basenode.pport0 to __move_base__local_costmap__footprinttopic.ROSTopicAdvertiserRoleT0;
    Attachment __move_basenode.pport1 to __move_base__feedbacktopic.ROSTopicAdvertiserRoleT0;
    Attachment __move_basenode.pport2 to __move_base__NavfnROS__plantopic.ROSTopicAdvertiserRoleT0;
    Attachment __move_basenode.pport3 to __move_base__global_costmap__footprinttopic.ROSTopicAdvertiserRoleT0;
    Attachment __move_basenode.pport4 to __move_base__local_costmap__obstacle_layer__parameter_updatestopic.ROSTopicAdvertiserRoleT0;
    Attachment __move_basenode.pport5 to __move_base__global_costmap__obstacle_layer__parameter_descriptionstopic.ROSTopicAdvertiserRoleT0;
    Attachment __move_basenode.pport6 to __move_base__global_costmap__inflation_layer__parameter_descriptionstopic.ROSTopicAdvertiserRoleT0;
    Attachment __move_basenode.pport7 to __move_base__current_goaltopic.ROSTopicAdvertiserRoleT0;
    Attachment __move_basenode.pport8 to __move_base__local_costmap__costmaptopic.ROSTopicAdvertiserRoleT0;
    Attachment __move_basenode.pport9 to __navigation_velocity_smoother__raw_cmd_veltopic.ROSTopicAdvertiserRoleT0;
    Attachment __move_basenode.pport10 to __move_base__local_costmap__inflation_layer__parameter_updatestopic.ROSTopicAdvertiserRoleT0;
    Attachment __move_basenode.pport11 to __move_base__parameter_updatestopic.ROSTopicAdvertiserRoleT0;
    Attachment __move_basenode.pport12 to __move_base__DWAPlannerROS__global_plantopic.ROSTopicAdvertiserRoleT0;
    Attachment __move_basenode.pport13 to __move_base__global_costmap__obstacle_layer__clearing_endpointstopic.ROSTopicAdvertiserRoleT0;
    Attachment __move_basenode.pport14 to __move_base__DWAPlannerROS__cost_cloudtopic.ROSTopicAdvertiserRoleT0;
    Attachment __move_basenode.pport15 to __move_base__local_costmap__parameter_updatestopic.ROSTopicAdvertiserRoleT0;
    Attachment __move_basenode.pport16 to __move_base__goaltopic.ROSTopicAdvertiserRoleT0;
    Attachment __move_basenode.pport17 to __move_base__global_costmap__obstacle_layer__parameter_updatestopic.ROSTopicAdvertiserRoleT0;
    Attachment __move_basenode.pport18 to __move_base__global_costmap__costmap_updatestopic.ROSTopicAdvertiserRoleT0;
    Attachment __move_basenode.pport19 to __move_base__local_costmap__inflation_layer__parameter_descriptionstopic.ROSTopicAdvertiserRoleT0;
    Attachment __move_basenode.pport20 to __move_base__DWAPlannerROS__trajectory_cloudtopic.ROSTopicAdvertiserRoleT0;
    Attachment __move_basenode.pport21 to __move_base__global_costmap__static_layer__parameter_updatestopic.ROSTopicAdvertiserRoleT0;
    Attachment __move_basenode.pport22 to __move_base__statustopic.ROSTopicAdvertiserRoleT0;
    Attachment __move_basenode.pport23 to __move_base__local_costmap__costmap_updatestopic.ROSTopicAdvertiserRoleT0;
    Attachment __move_basenode.pport24 to __move_base__local_costmap__parameter_descriptionstopic.ROSTopicAdvertiserRoleT0;
    Attachment __move_basenode.pport25 to __move_base__global_costmap__inflation_layer__parameter_updatestopic.ROSTopicAdvertiserRoleT0;
    Attachment __move_basenode.pport26 to __move_base__DWAPlannerROS__parameter_descriptionstopic.ROSTopicAdvertiserRoleT0;
    Attachment __move_basenode.pport27 to __rosouttopic.ROSTopicAdvertiserRoleT6;
    Attachment __move_basenode.pport28 to __move_base__local_costmap__obstacle_layer__clearing_endpointstopic.ROSTopicAdvertiserRoleT6;
    Attachment __move_basenode.pport29 to __move_base__global_costmap__costmaptopic.ROSTopicAdvertiserRoleT6;
    Attachment __move_basenode.pport30 to __move_base__DWAPlannerROS__parameter_updatestopic.ROSTopicAdvertiserRoleT6;
    Attachment __move_basenode.pport31 to __move_base__parameter_descriptionstopic.ROSTopicAdvertiserRoleT6;
    Attachment __move_basenode.pport32 to __move_base__global_costmap__parameter_updatestopic.ROSTopicAdvertiserRoleT6;
    Attachment __move_basenode.pport33 to __move_base__global_costmap__static_layer__parameter_descriptionstopic.ROSTopicAdvertiserRoleT6;
    Attachment __move_basenode.pport34 to __move_base__local_costmap__obstacle_layer__parameter_descriptionstopic.ROSTopicAdvertiserRoleT6;
    Attachment __move_basenode.pport35 to __move_base__global_costmap__parameter_descriptionstopic.ROSTopicAdvertiserRoleT6;
    Attachment __move_basenode.pport36 to __move_base__resulttopic.ROSTopicAdvertiserRoleT6;
    Attachment __move_basenode.pport37 to __move_base__DWAPlannerROS__local_plantopic.ROSTopicAdvertiserRoleT6;
    Attachment __ig_action_servernode.sport0 to __move_base__feedbacktopic.ROSTopicSubscriberRoleT0;
    Attachment __ig_action_servernode.sport1 to __euler_orientationtopic.ROSTopicSubscriberRoleT0;
    Attachment __ig_action_servernode.sport2 to __ig_action_server__goaltopic.ROSTopicSubscriberRoleT0;
    Attachment __ig_action_servernode.sport3 to __move_base__statustopic.ROSTopicSubscriberRoleT0;
    Attachment __ig_action_servernode.sport4 to __clocktopic.ROSTopicSubscriberRoleT8;
    Attachment __ig_action_servernode.sport5 to __ig_action_server__canceltopic.ROSTopicSubscriberRoleT8;
    Attachment __ig_action_servernode.sport6 to __move_base__resulttopic.ROSTopicSubscriberRoleT8;
    Attachment __ig_action_servernode.pport0 to __ig_action_server__feedbacktopic.ROSTopicAdvertiserRoleT0;
    Attachment __ig_action_servernode.pport1 to __ig_action_server__statustopic.ROSTopicAdvertiserRoleT0;
    Attachment __ig_action_servernode.pport2 to __ig_action_server__resulttopic.ROSTopicAdvertiserRoleT0;
    Attachment __ig_action_servernode.pport3 to __move_base__goaltopic.ROSTopicAdvertiserRoleT1;
    Attachment __ig_action_servernode.pport4 to __cmd_vel_mux__input__navitopic.ROSTopicAdvertiserRoleT1;
    Attachment __ig_action_servernode.pport5 to __rosouttopic.ROSTopicAdvertiserRoleT7;
    Attachment __ig_action_servernode.pport6 to __move_base__canceltopic.ROSTopicAdvertiserRoleT7;
    Attachment __ig_action_servernode.pport7 to __instructiongraphs_goaltopic.ROSTopicAdvertiserRoleT7;
    Attachment __ig_action_servernode.pport8 to __instructiongraphs_statustopic.ROSTopicAdvertiserRoleT7;
    Attachment __ig_action_clientnode.sport0 to __ig_action_server__feedbacktopic.ROSTopicSubscriberRoleT0;
    Attachment __ig_action_clientnode.sport1 to __ig_action_server__statustopic.ROSTopicSubscriberRoleT0;
    Attachment __ig_action_clientnode.sport2 to __ig_action_server__resulttopic.ROSTopicSubscriberRoleT0;
    Attachment __ig_action_clientnode.sport3 to __clocktopic.ROSTopicSubscriberRoleT9;
    Attachment __ig_action_clientnode.pport0 to __ig_action_server__goaltopic.ROSTopicAdvertiserRoleT0;
    Attachment __ig_action_clientnode.pport1 to __rosouttopic.ROSTopicAdvertiserRoleT8;
    Attachment __ig_action_clientnode.pport2 to __ig_action_server__canceltopic.ROSTopicAdvertiserRoleT8;
    Attachment __gazebonode.sport0 to __mobile_base__commands__velocitytopic.ROSTopicSubscriberRoleT0;
    Attachment __gazebonode.sport1 to __clocktopic.ROSTopicSubscriberRoleT10;
    Attachment __gazebonode.pport0 to __camera__rgb__image_raw__theora__parameter_descriptionstopic.ROSTopicAdvertiserRoleT0;
    Attachment __gazebonode.pport1 to __camera__rgb__camera_infotopic.ROSTopicAdvertiserRoleT0;
    Attachment __gazebonode.pport2 to __camera__parameter_descriptionstopic.ROSTopicAdvertiserRoleT0;
    Attachment __gazebonode.pport3 to __camera__rgb__image_raw__compressed__parameter_descriptionstopic.ROSTopicAdvertiserRoleT0;
    Attachment __gazebonode.pport4 to __camera__rgb__image_raw__compressedDepthtopic.ROSTopicAdvertiserRoleT0;
    Attachment __gazebonode.pport5 to __camera__rgb__image_raw__compressedDepth__parameter_descriptionstopic.ROSTopicAdvertiserRoleT0;
    Attachment __gazebonode.pport6 to __gazebo__model_statestopic.ROSTopicAdvertiserRoleT0;
    Attachment __gazebonode.pport7 to __camera__depth__pointstopic.ROSTopicAdvertiserRoleT0;
    Attachment __gazebonode.pport8 to __camera__rgb__image_raw__compressedDepth__parameter_updatestopic.ROSTopicAdvertiserRoleT0;
    Attachment __gazebonode.pport9 to __gazebo__parameter_descriptionstopic.ROSTopicAdvertiserRoleT0;
    Attachment __gazebonode.pport10 to __mobile_base__events__bumpertopic.ROSTopicAdvertiserRoleT0;
    Attachment __gazebonode.pport11 to __mobile_base__sensors__imu_datatopic.ROSTopicAdvertiserRoleT0;
    Attachment __gazebonode.pport12 to __camera__rgb__image_rawtopic.ROSTopicAdvertiserRoleT0;
    Attachment __gazebonode.pport13 to __tftopic.ROSTopicAdvertiserRoleT2;
    Attachment __gazebonode.pport14 to __camera__rgb__image_raw__compressedtopic.ROSTopicAdvertiserRoleT2;
    Attachment __gazebonode.pport15 to __camera__rgb__image_raw__compressed__parameter_updatestopic.ROSTopicAdvertiserRoleT2;
    Attachment __gazebonode.pport16 to __camera__parameter_updatestopic.ROSTopicAdvertiserRoleT2;
    Attachment __gazebonode.pport17 to __joint_statestopic.ROSTopicAdvertiserRoleT2;
    Attachment __gazebonode.pport18 to __rosouttopic.ROSTopicAdvertiserRoleT9;
    Attachment __gazebonode.pport19 to __camera__depth__image_rawtopic.ROSTopicAdvertiserRoleT9;
    Attachment __gazebonode.pport20 to __mobile_base__events__clifftopic.ROSTopicAdvertiserRoleT9;
    Attachment __gazebonode.pport21 to __camera__rgb__image_raw__theoratopic.ROSTopicAdvertiserRoleT9;
    Attachment __gazebonode.pport22 to __camera__rgb__image_raw__theora__parameter_updatestopic.ROSTopicAdvertiserRoleT9;
    Attachment __gazebonode.pport23 to __gazebo__parameter_updatestopic.ROSTopicAdvertiserRoleT9;
    Attachment __gazebonode.pport24 to __odomtopic.ROSTopicAdvertiserRoleT9;
    Attachment __gazebonode.pport25 to __camera__depth__camera_infotopic.ROSTopicAdvertiserRoleT9;
    Attachment __gazebonode.pport26 to __clocktopic.ROSTopicAdvertiserRoleT9;
    Attachment __gazebonode.pport27 to __gazebo__link_statestopic.ROSTopicAdvertiserRoleT9;
    Group group1 : ROSNodeManagerGroupT = new ROSNodeManagerGroupT extended with {

        Property name : string = "/laserscan_nodelet_manager";
        rule onlyNodelets = invariant forall m in self.MEMBERS | 
            (declaresType(m, ROSNodeletCompT) OR declaresType(m, ROSNodeManagerCompT));
        rule oneNodeManager = invariant exists unique m in self.MEMBERS | 
            declaresType(m, ROSNodeManagerCompT);
        Members {__laserscan_nodelet_managernode, __depthimage_to_laserscannode}

    }
    Group group2 : ROSNodeManagerGroupT = new ROSNodeManagerGroupT extended with {

        Property name : string = "/mobile_base_nodelet_manager";
        rule onlyNodelets = invariant forall m in self.MEMBERS | 
            (declaresType(m, ROSNodeletCompT) OR declaresType(m, ROSNodeManagerCompT));
        rule oneNodeManager = invariant exists unique m in self.MEMBERS | 
            declaresType(m, ROSNodeManagerCompT);
        Members {__mobile_base_nodelet_managernode, __bumper2pointcloudnode, __cmd_vel_muxnode, __kobuki_safety_controllernode, __navigation_velocity_smoothernode}

    }
    rule allNodeletsInGroup = invariant forall n :! ROSNodeletCompT in self.COMPONENTS | 
        exists unique m :! ROSNodeManagerGroupT in self.GROUPS | 
            contains(n, m.MEMBERS);
    rule topicsMatch = invariant forall s :! TopicSubscribePortT in /self/COMPONENTS/PORTS:!TopicSubscribePortT | 
        exists p :! TopicAdvertisePortT in /self/COMPONENTS/PORTS:!TopicAdvertisePortT | 
            (s.topic == p.topic AND s.msg_type == p.msg_type);
    rule onlyOneBusForTopicAndMsg = invariant forall t1,t2 :! TopicConnectorT in self.CONNECTORS | 
        ((t1.msg_type == t2.msg_type AND t1.topic == t2.topic) <-> t1 == t2);
    rule onlyOneBusForTopic = heuristic forall t1,t2 :! TopicConnectorT in self.CONNECTORS | 
        (t1.topic == t2.topic) <-> t1 == t2;
    rule noDuplicateNodes = invariant forall n2 :! ROSNodeCompT in self.COMPONENTS | 
        forall n1 :! ROSNodeCompT in self.COMPONENTS | 
            (n1.name == n2.name) <-> n1 == n2;
}

